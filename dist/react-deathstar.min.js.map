{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-deathstar.min.js","webpack:///webpack/bootstrap eeded22f5657bff19d05","webpack:///./src/index.js","webpack:///./src/DeathStar.js","webpack:///./src/Bridge.js","webpack:///./minify.conf.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Object","defineProperty","value","_DeathStar","enumerable","get","DeathStar","_interopRequireDefault","obj","__esModule","default","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","configurable","writable","key","protoProps","staticProps","prototype","_Bridge","_Bridge2","_minify","_minify2","react","createElement","storage","setStore","bind","checkKey","htmlDict","minify","minf","builder","putStore","getStore","deleteStore","keys","type","children","assign","indexOf","getId","context","forceUpdate","temp","map","current","state","_this","store","currentItem","currentStore","split","_this2","match","substring","replace","data","copy","arguments","undefined","newProps","ref","processChildren","arrChild","container","mapChildrens","manipulate","index","haveTypeName","push","displayName","name","s4","Math","floor","random","toString","jsxData","newKey","keyMaster","keyArr","walkChildren","console","log","tempJsx","getElement","swapPropsAttr","updateAllReferences","walk","x","keyNew","processElement","attributes","updated","checkProps","attValues","_this3","processModify","atrName","checkAttribute","tempVar","_this4","processRemove","splice","tempObj","result","childrenVal","mergeIndex","_arrChild","_arrChild2","apply","concat","_this5","processRemoveChildren","processResetChildren","jsxMaster","newArr","filter","idx","tempElement","childrenUpdated","checkChildrensInArray","mainElement","currentElement","childrens","nextChildrens","compareChildrens","newAttr","tempProps","_DeathStar2","Bridge","getInstance","setAttribute","setProps","modifyAttribute","removeAttribute","setChildren","removeChildren","manipulateCopy","destroy","ninf"],"mappings":"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","file":"react-deathstar.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"react-deathstar\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"react-deathstar\"] = factory();\n\telse\n\t\troot[\"react-deathstar\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"react-deathstar\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"react-deathstar\"] = factory();\n\telse\n\t\troot[\"react-deathstar\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _DeathStar = __webpack_require__(1);\n\t\n\tObject.defineProperty(exports, 'DeathStar', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _DeathStar.DeathStar;\n\t  }\n\t});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Bridge = __webpack_require__(2);\n\t\n\tvar _Bridge2 = _interopRequireDefault(_Bridge);\n\t\n\tvar _minify = __webpack_require__(3);\n\t\n\tvar _minify2 = _interopRequireDefault(_minify);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar instance = '';\n\t\n\tvar DeathStar = function () {\n\t\n\t  /**\r\n\t   * Construtor da classe\r\n\t   * \r\n\t   * @param {object} react \r\n\t   */\n\t  function DeathStar(react) {\n\t    _classCallCheck(this, DeathStar);\n\t\n\t    this.createElement = react.createElement;\n\t    this.storage = {};\n\t    this.setStore.bind(this);\n\t    this.checkKey.bind(this);\n\t    this.htmlDict = [];\n\t    this.minify = _minify2.default.minify;\n\t    this.minf.bind(this);\n\t    this.builder.bind(this);\n\t    this.putStore.bind(this);\n\t    this.getStore.bind(this);\n\t    this.deleteStore.bind(this);\n\t    this.keys.bind(this);\n\t  }\n\t\n\t  /**\r\n\t   * Recupera a instancia corrente do react pelo componente que o utilizará\r\n\t   * \r\n\t   * @param {object} react\r\n\t   * @return {object}\r\n\t   */\n\t\n\t\n\t  _createClass(DeathStar, [{\n\t    key: 'builder',\n\t\n\t\n\t    /**\r\n\t     * Recria o componente informado com seu devido mapeamento para manipulação\r\n\t     * \r\n\t     * @param {string | object} type \r\n\t     * @param {object} props \r\n\t     * @param {object} children\r\n\t     * @return {object}\r\n\t     */\n\t    value: function builder(type, props, children) {\n\t      if (children && children.length === 0) children = null;\n\t      props = props.children ? Object.assign({}, props, { children: null }) : props;\n\t      props = Object.keys(props).indexOf('key') !== -1 ? Object.assign({}, props, { key: props.key }) : Object.assign({}, props, { key: this.getId() });\n\t      return this.createElement(type, props, children);\n\t    }\n\t\n\t    /**\r\n\t     * Limpa o repositório local de informações\r\n\t     */\n\t\n\t  }, {\n\t    key: 'clearBus',\n\t    value: function clearBus() {\n\t      this.storage = {};\n\t    }\n\t\n\t    /**\r\n\t     * Persiste os dados informados no repositório local\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {object} value \r\n\t     * @param {object} context\r\n\t     * @return {object | undefined}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'putStore',\n\t    value: function putStore(key, value, context) {\n\t      if (context) {\n\t        value['deathStartUpdater'] = function () {\n\t          value.forceUpdate();\n\t        };\n\t        var temp = {};\n\t        Object.keys(value).map(function (current) {\n\t          if (typeof value[current] === 'function') {\n\t            temp[current] = value[current];\n\t          }\n\t        });\n\t        temp['state'] = value.state;\n\t        this.storage[key] = temp;\n\t      } else {\n\t        this.storage[key] = value;\n\t        return value;\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Recupera o dado do repositório por meio da 'Key' informada \r\n\t     * \r\n\t     * @param {string} key\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'getStore',\n\t    value: function getStore(key) {\n\t      return this.storage[key];\n\t    }\n\t\n\t    /**\r\n\t     * Remove o objeto do repositório por meio da 'Key' informada\r\n\t     * \r\n\t     * @param {string} key \r\n\t     */\n\t\n\t  }, {\n\t    key: 'deleteStore',\n\t    value: function deleteStore(key) {\n\t      delete this.storage[key];\n\t    }\n\t\n\t    /**\r\n\t     * Recupera todas as chaves realcionadas aos objetos persistidos no repositório\r\n\t     * @return {array}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'keys',\n\t    value: function keys() {\n\t      return Object.keys(this.storage);\n\t    }\n\t\n\t    /**\r\n\t     * Destrói os elementos React do repositório por meio da lista de Arrays informados.\r\n\t     * \r\n\t     * @param {array | string} keys \r\n\t     */\n\t\n\t  }, {\n\t    key: 'destroy',\n\t    value: function destroy(keys) {\n\t      var _this = this;\n\t\n\t      if (keys instanceof Array) {\n\t        var store = this.keys();\n\t        keys.map(function (currentItem) {\n\t          store.map(function (currentStore) {\n\t            if (currentStore.split('-')[0] === currentItem) {\n\t              _this.deleteStore(currentItem);\n\t            }\n\t          }, _this);\n\t        }, this);\n\t      } else {\n\t        var _store = this.keys();\n\t        _store.map(function (currentStore) {\n\t          if (currentStore.split('-')[0] === keys) {\n\t            _this.deleteStore(currentStore);\n\t          }\n\t        }, this);\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Realiza a minificação dos tipos de objetos React fazendo a compressão de nomes dos componentes.\r\n\t     * \r\n\t     * @param {string} key\r\n\t     * @return {string}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'minf',\n\t    value: function minf(key) {\n\t      var _this2 = this;\n\t\n\t      if (this.minify) {\n\t        key.match(/(-\\w[a-zA-Z]+)/g) ? key.match(/(-\\w[a-zA-Z]+)/g).map(function (current) {\n\t          if (_this2.htmlDict.indexOf(current.substring(1, key.length)) === -1) {\n\t            key = key.replace(current.substring(1, key.length), \"t\");\n\t          }\n\t        }) : \"\";\n\t      }\n\t      return key;\n\t    }\n\t\n\t    /**\r\n\t     * Prepara um container de informações para serem criadas e indexadas.\r\n\t     * \r\n\t     * @param {object} data \r\n\t     * @param {boolean} copy\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'container',\n\t    value: function container(data) {\n\t      var copy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t      var newProps = data.props;\n\t      if (Object.keys(data).indexOf('key') !== -1 && data['key'] && !copy) newProps = Object.assign({}, newProps, { key: data.key });\n\t      if (Object.keys(data).indexOf('ref') !== -1 && data['ref']) newProps = Object.assign({}, newProps, { ref: data.ref });\n\t      return this.builder(data.type, newProps ? newProps : null, Object.keys(data.props).indexOf('children') !== -1 ? this.processChildren(data.props.children, copy) : []);\n\t    }\n\t\n\t    /**\r\n\t     * Processa os filhos de um elemento React para que possam ser mapeados para manipulação.\r\n\t     * \r\n\t     * @param {object | array} children \r\n\t     * @param {boolean} copy\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'processChildren',\n\t    value: function processChildren(children, copy) {\n\t      return children ? children instanceof Array ? children.length > 0 ? children.map(function (arrChild) {\n\t        if (arrChild) return arrChild.type ? this.container(arrChild, copy) : arrChild;\n\t      }, this) : null : children.type ? this.container(children, copy) : children : null;\n\t    }\n\t\n\t    /**\r\n\t     * Processa um elemento React para que possam ser mapeado para manipulação.\r\n\t     * \r\n\t     * @param {object} data \r\n\t     * @param {string} key \r\n\t     * @param {boolean} copy\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'processElement',\n\t    value: function processElement(data, key) {\n\t      var copy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      var obj = this.setStore(key, data, copy);\n\t      this.mapChildrens(obj.props.children, key);\n\t      return this.manipulate(key);\n\t    }\n\t\n\t    /**\r\n\t     * Mapeia os filhos processados de um elemento para indexação no repositório\r\n\t     * \r\n\t     * @param {object} data \r\n\t     * @param {string} key \r\n\t     */\n\t\n\t  }, {\n\t    key: 'mapChildrens',\n\t    value: function mapChildrens(data, key) {\n\t      if (data) {\n\t        if (data instanceof Array) {\n\t          data.map(function (current, index) {\n\t            if (current) {\n\t              ++index;\n\t              if (current.props) this.mapChildrens(current.props.children, key + '-' + this.haveTypeName(current.type) + index);\n\t              if (current.props) this.putStore(key + '-' + this.haveTypeName(current.type) + index, current.key);\n\t            }\n\t          }, this);\n\t        } else {\n\t          if (data.props) this.mapChildrens(data.props.children, key + '-' + this.haveTypeName(data.type) + '1');\n\t          if (data.props) this.putStore(key + '-' + this.haveTypeName(data.type) + '1', data.key);\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Verifica se o tipo do componente já foi inserido no dicionário de tipos, caso não exista ele o insere\r\n\t     * \r\n\t     * @param {string} type\r\n\t     * @return {string}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'haveTypeName',\n\t    value: function haveTypeName(type) {\n\t      if (this.minify && typeof type === 'string') {\n\t        if (this.htmlDict.indexOf(type) === -1) this.htmlDict.push(type);\n\t      }\n\t      return type.displayName ? type.displayName : type.name ? type.name : type;\n\t    }\n\t\n\t    /**\r\n\t     * Recupera um ID único para uso no mapeamento de elementos.\r\n\t     * @return {string}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'getId',\n\t    value: function getId() {\n\t      function s4() {\n\t        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n\t      }\n\t      return s4() + s4() + '_' + s4() + '_' + s4() + '_' + s4() + '_' + s4() + s4() + s4();\n\t    }\n\t\n\t    /**\r\n\t     * Insere no repositório um elemento react novo\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {object} jsxData \r\n\t     * @param {boolean} copy\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'setStore',\n\t    value: function setStore(key, jsxData) {\n\t      var copy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      return this.putStore(key, this.container(jsxData, copy));\n\t    }\n\t\n\t    /**\r\n\t     * Recupera um elemento React do repositório e o disponibiliza para manipulação.\r\n\t     * \r\n\t     * @param {string} key\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'manipulate',\n\t    value: function manipulate(key) {\n\t      key = this.minf(key);\n\t      return this.checkKey(key) ? new _Bridge2.default(key) : '';\n\t    }\n\t\n\t    /**\r\n\t     * Recupera um elemento React do repositório cria uma cópia com a nova chave e o disponibiliza para manipulação.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {string} newKey\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'manipulateCopy',\n\t    value: function manipulateCopy(key, newKey) {\n\t      key = this.minf(key);\n\t      return this.manipulate(key).copy(newKey);\n\t    }\n\t\n\t    /**\r\n\t     * Recupera um elemento do repositório para renderização\r\n\t     * \r\n\t     * @param {string} key\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'getElement',\n\t    value: function getElement(key) {\n\t      key = this.minf(key);\n\t      if (this.checkKey(key)) {\n\t        var temp = this.getStore(key);\n\t        var keyMaster = temp.props ? temp.key : temp;\n\t        var keyArr = key.split('-');\n\t        if (this.checkKey(keyArr[0])) {\n\t          var obj = this.getStore(keyArr[0]);\n\t          return obj.key === keyMaster ? obj : this.walkChildren(obj.props.children, keyMaster);\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Recupera do repositório e insere um novo Props no elemento relacionado a key informada.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {object} props \r\n\t     */\n\t\n\t  }, {\n\t    key: 'setProps',\n\t    value: function setProps(key, props) {\n\t\n\t      if (!key && !(props instanceof Object)) {\n\t        console.log('metodo: setProps - Você precisa especificar uma key em string e um props no formato objeto!');\n\t        return;\n\t      }\n\t      if (this.checkKey(key)) {\n\t        var tempJsx = this.getElement(key);\n\t        if (Object.keys(props).indexOf('ref') !== -1) {\n\t          tempJsx = Object.assign({}, tempJsx, { ref: props.ref });\n\t          delete props.ref;\n\t        }\n\t        tempJsx = this.swapPropsAttr(tempJsx, props);\n\t        this.updateAllReferences(tempJsx);\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Realiza a descoberta de elementos filhos de um elemento e retorna os elementos encontrados.\r\n\t     * \r\n\t     * @param {object} data \r\n\t     * @param {string} key\r\n\t     * @return {array}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'walkChildren',\n\t    value: function walkChildren(data, key) {\n\t      var walk = '';\n\t      if (data) {\n\t        if (data instanceof Array) {\n\t          for (var x = 0; x < data.length; x++) {\n\t            if (data[x]) {\n\t              if (data[x].key === key) return data[x];else if (data[x].props) walk = this.walkChildren(data[x].props.children, key);\n\t              if (walk && walk.key === key) return walk;\n\t            }\n\t          }\n\t        } else {\n\t          if (data.key === key) return data;else if (data.props) walk = this.walkChildren(data.props.children, key);\n\t          if (walk && walk.key === key) return walk;\n\t        }\n\t      }return;\n\t    }\n\t\n\t    /**\r\n\t     * Recupera o elemento por meio de sua chave e realiza a cópia do mesmo por meio da nova chave\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {string} keyNew\r\n\t     * @return {object | undefined} \r\n\t     */\n\t\n\t  }, {\n\t    key: 'copy',\n\t    value: function copy(key, keyNew) {\n\t      return this.checkKey(key) ? this.processElement(this.getElement(key), keyNew, true) : '';\n\t    }\n\t\n\t    /**\r\n\t     * Insere um novo atributo no objeto relacionado a chave informada.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {object} attributes \r\n\t     */\n\t\n\t  }, {\n\t    key: 'setAttribute',\n\t    value: function setAttribute(key, attributes) {\n\t      if (!key && !attributes || !(attributes instanceof Object)) {\n\t        console.log('metodo: setAttributes - Você precisa especificar uma key em string e um atributo no formato objeto!');\n\t        return;\n\t      }\n\t      if (this.checkKey(key)) {\n\t        if (attributes.ref) {\n\t          var tempJsx = this.getElement(key);\n\t          var updated = Object.assign({}, tempJsx, attributes);\n\t          this.updateAllReferences(updated);\n\t        } else {\n\t          if (this.checkProps(key)) {\n\t            var _tempJsx = this.getElement(key);\n\t            var _updated = this.swapPropsAttr(_tempJsx, attributes);\n\t            this.updateAllReferences(_updated);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Reaplica um novo valor ao atributo passado ao objeto por meio da chave informada.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {object} attValues \r\n\t     */\n\t\n\t  }, {\n\t    key: 'modifyAttribute',\n\t    value: function modifyAttribute(key, attValues) {\n\t      var _this3 = this;\n\t\n\t      Object.keys(attValues).map(function (current) {\n\t        _this3.processModify(key, current, attValues[current]);\n\t      }, this);\n\t    }\n\t\n\t    /**\r\n\t     * Aplica as mudanças nos atributos de acordo com os valores informados.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {string} atrName \r\n\t     * @param {*} value \r\n\t     */\n\t\n\t  }, {\n\t    key: 'processModify',\n\t    value: function processModify(key, atrName, value) {\n\t      if (!key && !atrName && !value) {\n\t        console.log('metodo: modifyAttribute - Você precisa especificar a key, o nome do atributo e seu valor por parâmetro!');\n\t        return;\n\t      }\n\t      if (this.checkKey(key)) {\n\t        if (this.checkProps(key)) {\n\t          if (this.checkAttribute(key, atrName) || atrName === 'ref') {\n\t            var tempJsx = this.getElement(key);\n\t            if (atrName === 'ref') {\n\t              var updated = Object.assign({}, tempJsx, { ref: value });\n\t              this.updateAllReferences(updated);\n\t            } else {\n\t              var tempVar = {};\n\t              tempVar[atrName] = value;\n\t              var _updated2 = this.swapPropsAttr(tempJsx, tempVar);\n\t              this.updateAllReferences(_updated2);\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Recupera o elemento do repositório e realiza a remoção dos atributos informados\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {array | string} attValues \r\n\t     */\n\t\n\t  }, {\n\t    key: 'removeAttribute',\n\t    value: function removeAttribute(key, attValues) {\n\t      var _this4 = this;\n\t\n\t      if (attValues instanceof Array) {\n\t        attValues.map(function (current) {\n\t          _this4.processRemove(key, current);\n\t        }, this);\n\t      } else {\n\t        this.processRemove(key, attValues);\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Aplica a remoção dos atributos de acordo com os valores informados.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {string} atrName \r\n\t     */\n\t\n\t  }, {\n\t    key: 'processRemove',\n\t    value: function processRemove(key, atrName) {\n\t      if (!key && !atrName) {\n\t        console.log('metodo: removeAttribute - Você precisa especificar uma key em string e o nome do atributo a ser removido!');\n\t        return;\n\t      }\n\t      if (this.checkKey(key)) {\n\t        if (this.checkProps(key)) {\n\t          var tempJsx = this.getElement(key);\n\t          if (atrName === 'ref') {\n\t            var updated = Object.assign({}, tempJsx, { ref: null });\n\t            this.updateAllReferences(updated);\n\t          }\n\t          if (this.checkAttribute(key, atrName)) {\n\t            var index = Object.keys(tempJsx.props);\n\t            index.splice(index.indexOf(atrName), 1);\n\t            var tempObj = {};\n\t            index.map(function (current) {\n\t              tempObj[current] = tempJsx.props[current];\n\t            });\n\t            var result = Object.assign({}, tempJsx, { props: tempObj });\n\t            this.updateAllReferences(result);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Realiza a inserção de um elemento filho em um outro elemento especificado pela chave.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {object} childrenVal \r\n\t     * @param {integer} index \r\n\t     * @param {boolean} mergeIndex \r\n\t     */\n\t\n\t  }, {\n\t    key: 'setChildren',\n\t    value: function setChildren(key, childrenVal) {\n\t      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\t      var mergeIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\t\n\t      if (!key && !childrenVal) {\n\t        console.log('metodo: setChildren - Você precisa especificar a key e um elemento a ser inserido!');\n\t        return;\n\t      }\n\t      if (this.checkKey(key)) {\n\t        var tempJsx = this.getElement(key);\n\t        if (this.checkProps(key)) {\n\t          if (tempJsx.props.children) {\n\t            if (childrenVal instanceof Array) {\n\t              var arrChild = tempJsx.props.children;\n\t              if (!(arrChild instanceof Array)) arrChild = new Array(arrChild);\n\t              var updated = {};\n\t              if (index) {\n\t                var _arrChild, _arrChild2;\n\t\n\t                index--;\n\t                if (mergeIndex) (_arrChild = arrChild).splice.apply(_arrChild, [index, 0].concat(_toConsumableArray(childrenVal)));else (_arrChild2 = arrChild).splice.apply(_arrChild2, [index, 1].concat(_toConsumableArray(childrenVal)));\n\t                updated = this.swapPropsAttr(tempJsx, { children: arrChild });\n\t              } else updated = this.swapPropsAttr(tempJsx, { children: arrChild.concat(childrenVal) });\n\t              this.updateAllReferences(updated);\n\t            } else {\n\t              var _arrChild3 = tempJsx.props.children instanceof Array ? tempJsx.props.children : new Array(tempJsx.props.children);\n\t              if (index) {\n\t                index--;\n\t                if (mergeIndex) _arrChild3.splice(index, 0, childrenVal);else _arrChild3[index] = childrenVal;\n\t              } else {\n\t                _arrChild3.push(childrenVal);\n\t              }\n\t              var _updated3 = this.swapPropsAttr(tempJsx, { children: _arrChild3 });\n\t              this.updateAllReferences(_updated3);\n\t            }\n\t          } else {\n\t            var _updated4 = this.swapPropsAttr(tempJsx, { children: childrenVal });\n\t            this.updateAllReferences(_updated4);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Recupera um elemento pela chave e realiza a remoção do filho especificado pela indice informado.\r\n\t     * o indice obedece a regra da ordem dos filhos do elemento pai.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {intger} index \r\n\t     */\n\t\n\t  }, {\n\t    key: 'removeChildren',\n\t    value: function removeChildren(key, index) {\n\t      var _this5 = this;\n\t\n\t      if (index instanceof Array && index !== -1) {\n\t        index.map(function (current) {\n\t          _this5.processRemoveChildren(key, current);\n\t        }, this);\n\t      } else if (index === -1) {\n\t        this.processResetChildren(key);\n\t      } else this.processRemoveChildren(key, index);\n\t    }\n\t\n\t    /**\r\n\t     * Aplica a remoção do filho de acordo com os valores informados.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {integer} index \r\n\t     */\n\t\n\t  }, {\n\t    key: 'processRemoveChildren',\n\t    value: function processRemoveChildren(key, index) {\n\t      index--;\n\t      if (!key && index) {\n\t        console.log('metodo: removeChildren - Você precisa especificar a key onde será retirada a children e o índice que corresponde a children a ser removida!');\n\t        return;\n\t      }\n\t      if (this.checkKey(key)) {\n\t        var jsxMaster = this.getElement(key);\n\t        if (jsxMaster.props.children instanceof Array) {\n\t          var newArr = jsxMaster.props.children.filter(function (current, idx) {\n\t            return index !== idx;\n\t          });\n\t          var updated = this.swapPropsAttr(jsxMaster, { children: newArr });\n\t          this.updateAllReferences(updated);\n\t        } else {\n\t          var _updated5 = this.swapPropsAttr(jsxMaster, { children: null });\n\t          this.updateAllReferences(_updated5);\n\t        }\n\t      } else console.log('Chave não encontrada!');\n\t    }\n\t\n\t    /**\r\n\t     * Remove todos os filhos de um elemento recuperado pela chave.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     */\n\t\n\t  }, {\n\t    key: 'processResetChildren',\n\t    value: function processResetChildren(key) {\n\t      if (!key) {\n\t        console.log('metodo: removeChildren - Você precisa especificar a key onde será retirada os childrens !');\n\t        return;\n\t      }\n\t      if (this.checkKey(key)) {\n\t        var jsxMaster = this.getElement(key);\n\t        var updated = this.swapPropsAttr(jsxMaster, { children: null });\n\t        this.updateAllReferences(updated);\n\t      } else console.log('Chave não encontrada!');\n\t    }\n\t\n\t    /**\r\n\t     * Realiza a atualização das mudanças em todo o repositório\r\n\t     * \r\n\t     * @param {object} obj \r\n\t     */\n\t\n\t  }, {\n\t    key: 'updateAllReferences',\n\t    value: function updateAllReferences(obj) {\n\t\n\t      var keys = this.keys();\n\t      keys.map(function (current) {\n\t        var tempElement = this.getStore(current);\n\t        if (tempElement.props) {\n\t          if (tempElement.key !== obj.key) {\n\t            var childrenUpdated = this.checkChildrensInArray(obj, tempElement);\n\t            this.putStore(current, this.processElement(this.swapPropsAttr(tempElement, { children: childrenUpdated }), current).getElement());\n\t          } else this.putStore(current, this.processElement(obj, current).getElement());\n\t        }\n\t      }, this);\n\t    }\n\t\n\t    /**\r\n\t     * Verifica e aplica as mudanças nos filhos de um elemento pai.\r\n\t     * \r\n\t     * @param {object} mainElement \r\n\t     * @param {object} currentElement\r\n\t     * @return {object} \r\n\t     */\n\t\n\t  }, {\n\t    key: 'checkChildrensInArray',\n\t    value: function checkChildrensInArray(mainElement, currentElement) {\n\t\n\t      if (currentElement && currentElement.props) {\n\t        var childrens = currentElement.props.children;\n\t        var childrenUpdated = [];\n\t        if (childrens && childrens instanceof Array) {\n\t          childrens.map(function (current) {\n\t            var nextChildrens = this.checkChildrensInArray(mainElement, current);\n\t            childrenUpdated = this.compareChildrens(mainElement, current, childrenUpdated, nextChildrens);\n\t          }, this);\n\t          return childrenUpdated;\n\t        } else if (childrens && childrens.props) {\n\t          var nextChildrens = this.checkChildrensInArray(mainElement, childrens);\n\t          childrenUpdated = this.compareChildrens(mainElement, childrens, childrenUpdated, nextChildrens);\n\t          return childrenUpdated;\n\t        } else return childrens;\n\t      } else return currentElement;\n\t    }\n\t\n\t    /**\r\n\t     * Verifica se houve alteração no filho encontrado e recupera o filho atualizado.\r\n\t     * \r\n\t     * @param {object} mainElement \r\n\t     * @param {object} current \r\n\t     * @param {object} childrenUpdated \r\n\t     * @param {object} nextChildrens\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'compareChildrens',\n\t    value: function compareChildrens(mainElement, current, childrenUpdated, nextChildrens) {\n\t      if (current && current.key && current.key === mainElement.key) {\n\t        childrenUpdated.push(mainElement);\n\t      } else {\n\t        if (current && current.props) childrenUpdated.push(this.swapPropsAttr(current, { children: nextChildrens }));else childrenUpdated.push(current);\n\t      }\n\t      return childrenUpdated;\n\t    }\n\t\n\t    /**\r\n\t     * Realiza a inserção de novos atributos a um elemento informado.\r\n\t     * \r\n\t     * @param {object} obj \r\n\t     * @param {object} newAttr\r\n\t     * @return {object} \r\n\t     */\n\t\n\t  }, {\n\t    key: 'swapPropsAttr',\n\t    value: function swapPropsAttr(obj, newAttr) {\n\t      var tempProps = Object.assign({}, obj.props, newAttr);\n\t      return Object.assign({}, obj, { props: tempProps });\n\t    }\n\t\n\t    /**\r\n\t     * Verifica se existe algum item no repositório relacionado a chave informada.\r\n\t     * \r\n\t     * @param {string} key\r\n\t     * @return {boolean} \r\n\t     */\n\t\n\t  }, {\n\t    key: 'checkKey',\n\t    value: function checkKey(key) {\n\t      return this.keys().indexOf(key) === -1 ? false : true;\n\t    }\n\t\n\t    /**\r\n\t     * Verifica se o elemento relacionado a chave informada contém props.\r\n\t     * \r\n\t     * @param {string} key\r\n\t     * @return {boolean} \r\n\t     */\n\t\n\t  }, {\n\t    key: 'checkProps',\n\t    value: function checkProps(key) {\n\t      return this.checkKey(key) ? Object.keys(this.getElement(key)).indexOf('props') === -1 ? false : true : false;\n\t    }\n\t\n\t    /**\r\n\t     * Verifica se o elemento relacionado a chave informada contém o atributo indicado.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {string} atrName\r\n\t     * @return {boolean} \r\n\t     */\n\t\n\t  }, {\n\t    key: 'checkAttribute',\n\t    value: function checkAttribute(key, atrName) {\n\t      return this.checkKey(key) ? this.checkProps(key) ? Object.keys(this.getElement(key).props).indexOf(atrName) === -1 ? false : true : false : false;\n\t    }\n\t  }], [{\n\t    key: 'getInstance',\n\t    value: function getInstance(react) {\n\t      if (instance) {\n\t        return instance;\n\t      } else {\n\t        instance = new DeathStar(react);\n\t        return instance;\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return DeathStar;\n\t}();\n\t\n\texports.default = DeathStar;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _DeathStar = __webpack_require__(1);\n\t\n\tvar _DeathStar2 = _interopRequireDefault(_DeathStar);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Bridge = function () {\n\t  function Bridge(key) {\n\t    _classCallCheck(this, Bridge);\n\t\n\t    this.instance = _DeathStar2.default.getInstance();\n\t    this.key = this.instance.minf(key);\n\t  }\n\t  /**\r\n\t   * Retorna a chave relacionada a manipulação corrente\r\n\t   * \r\n\t   * @return {string}\r\n\t   */\n\t\n\t\n\t  _createClass(Bridge, [{\n\t    key: 'getMyKey',\n\t    value: function getMyKey() {\n\t      return this.key;\n\t    }\n\t\n\t    /**\r\n\t     * Recupera o elemento relacionado a chave deste manipulador para renderização\r\n\t     * \r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'getElement',\n\t    value: function getElement() {\n\t      return this.instance.getElement(this.key);\n\t    }\n\t\n\t    /**\r\n\t     * Recupera o elemento relacionado a chave deste manipulador e realiza a cópia do mesmo por meio da nova chave\r\n\t     * \r\n\t     * @param {string} newKey\r\n\t     * @return {object | undefined}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'copy',\n\t    value: function copy(newKey) {\n\t      return this.instance.copy(this.key, newKey);\n\t    }\n\t\n\t    /**\r\n\t     * Insere novos atributos no objeto relacionado a chave deste manipulador.\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {object} attributes\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'setAttribute',\n\t    value: function setAttribute(attributes) {\n\t      this.instance.setAttribute(this.key, attributes);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Recupera do repositório e insere um novo Props no elemento relacionado a chave deste manipulador.\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {object} props\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'setProps',\n\t    value: function setProps(props) {\n\t      this.instance.setProps(this.key, props);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Reaplica um novo valor ao atributo passado ao objeto relacionado a chave deste manipulador.\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {object} value\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'modifyAttribute',\n\t    value: function modifyAttribute(value) {\n\t      this.instance.modifyAttribute(this.key, value);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Recupera o elemento do repositório relacionado a chave deste manipulador e realiza a remoção dos atributos informados\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {string} atrName\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'removeAttribute',\n\t    value: function removeAttribute(atrName) {\n\t      this.instance.removeAttribute(this.key, atrName);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Realiza a inserção de um elemento filho em um outro elemento especificado relacionado a chave deste manipulador.\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {object} children \r\n\t     * @param {integer} index \r\n\t     * @param {boolean} mergeIndex\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'setChildren',\n\t    value: function setChildren(children) {\n\t      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\t      var mergeIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      this.instance.setChildren(this.key, children, index, mergeIndex);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Recupera um elemento relacionado a chave deste manipulador e realiza a remoção do filho especificado pela índice informado.\r\n\t     * o índice obedece a regra da ordem dos filhos do elemento pai.\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {integer} index\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'removeChildren',\n\t    value: function removeChildren(index) {\n\t      this.instance.removeChildren(this.key, index);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Verifica se o elemento relacionado a chave deste manipulador contém o atributo indicado.\r\n\t     * \r\n\t     * @param {string} atrName\r\n\t     * @return {boolean} \r\n\t     */\n\t\n\t  }, {\n\t    key: 'checkAttribute',\n\t    value: function checkAttribute(atrName) {\n\t      return this.instance.checkAttribute(this.key, atrName);\n\t    }\n\t\n\t    /**\r\n\t     * Recupera o elemento React relacionado a chave deste manipulador, cria uma cópia com a nova chave e o disponibiliza para manipulação.\r\n\t     * \r\n\t     * @param {string} newKey\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'manipulateCopy',\n\t    value: function manipulateCopy(newKey) {\n\t      return this.instance.manipulateCopy(this.key, newKey);\n\t    }\n\t\n\t    /**\r\n\t     * Carrega este manipulador de elemento com a nova chave informada\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'manipulate',\n\t    value: function manipulate(key) {\n\t      this.key = this.instance.minf(key);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Destrói os elementos React do repositório por meio da lista de Arrays informados.\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {array | string} keys\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'destroy',\n\t    value: function destroy(keys) {\n\t      this.instance.destroy(keys);\n\t      return this;\n\t    }\n\t  }]);\n\t\n\t  return Bridge;\n\t}();\n\t\n\texports.default = Bridge;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tvar ninf = {\n\t  minify: true\n\t};\n\t\n\tmodule.exports = ninf;\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// react-deathstar.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap eeded22f5657bff19d05","export { DeathStar } from './DeathStar';\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import Bridge from './Bridge';\r\nimport ninf from '../minify.conf';\r\n\r\nlet instance = '';\r\n\r\nexport default class DeathStar {\r\n\r\n  /**\r\n   * Construtor da classe\r\n   * \r\n   * @param {object} react \r\n   */\r\n  constructor(react) {\r\n    this.createElement = react.createElement;\r\n    this.storage = {};\r\n    this.setStore.bind(this);\r\n    this.checkKey.bind(this);\r\n    this.htmlDict = [];\r\n    this.minify = ninf.minify;\r\n    this.minf.bind(this);\r\n    this.builder.bind(this);\r\n    this.putStore.bind(this);\r\n    this.getStore.bind(this);\r\n    this.deleteStore.bind(this);\r\n    this.keys.bind(this);\r\n  }\r\n\r\n  /**\r\n   * Recupera a instancia corrente do react pelo componente que o utilizará\r\n   * \r\n   * @param {object} react\r\n   * @return {object}\r\n   */\r\n  static getInstance(react) {\r\n    if (instance) {\r\n      return instance;\r\n    } else {\r\n      instance = new DeathStar(react);\r\n      return instance;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recria o componente informado com seu devido mapeamento para manipulação\r\n   * \r\n   * @param {string | object} type \r\n   * @param {object} props \r\n   * @param {object} children\r\n   * @return {object}\r\n   */\r\n  builder(type, props, children) {\r\n    if (children && children.length === 0) children = null;\r\n    props = props.children ? Object.assign({}, props, { children: null }) : props;\r\n    props = (Object.keys(props).indexOf('key') !== -1) ? Object.assign({}, props, { key: props.key }) : Object.assign({}, props, { key: this.getId() });\r\n    return this.createElement(type, props, children);\r\n  }\r\n\r\n  /**\r\n   * Limpa o repositório local de informações\r\n   */\r\n  clearBus() {\r\n    this.storage = {};\r\n  }\r\n\r\n  /**\r\n   * Persiste os dados informados no repositório local\r\n   * \r\n   * @param {string} key \r\n   * @param {object} value \r\n   * @param {object} context\r\n   * @return {object | undefined}\r\n   */\r\n  putStore(key, value, context) {\r\n    if (context) {\r\n      value['deathStartUpdater'] = () => { value.forceUpdate(); };\r\n      let temp = {};\r\n      Object.keys(value).map((current) => {\r\n        if (typeof (value[current]) === 'function') {\r\n          temp[current] = value[current];\r\n        }\r\n      });\r\n      temp['state'] = value.state;\r\n      this.storage[key] = temp;\r\n    } else {\r\n      this.storage[key] = value;\r\n      return value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recupera o dado do repositório por meio da 'Key' informada \r\n   * \r\n   * @param {string} key\r\n   * @return {object}\r\n   */\r\n  getStore(key) {\r\n    return this.storage[key];\r\n  }\r\n\r\n  /**\r\n   * Remove o objeto do repositório por meio da 'Key' informada\r\n   * \r\n   * @param {string} key \r\n   */\r\n  deleteStore(key) {\r\n    delete this.storage[key];\r\n  }\r\n\r\n  /**\r\n   * Recupera todas as chaves realcionadas aos objetos persistidos no repositório\r\n   * @return {array}\r\n   */\r\n  keys() {\r\n    return Object.keys(this.storage);\r\n  }\r\n\r\n  /**\r\n   * Destrói os elementos React do repositório por meio da lista de Arrays informados.\r\n   * \r\n   * @param {array | string} keys \r\n   */\r\n  destroy(keys) {\r\n    if (keys instanceof Array) {\r\n      let store = this.keys();\r\n      keys.map((currentItem) => {\r\n        store.map((currentStore) => {\r\n          if (currentStore.split('-')[0] === currentItem) {\r\n            this.deleteStore(currentItem);\r\n          }\r\n        }, this);\r\n      }, this);\r\n    } else {\r\n      let store = this.keys();\r\n      store.map((currentStore) => {\r\n        if (currentStore.split('-')[0] === keys) {\r\n          this.deleteStore(currentStore);\r\n        }\r\n      }, this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Realiza a minificação dos tipos de objetos React fazendo a compressão de nomes dos componentes.\r\n   * \r\n   * @param {string} key\r\n   * @return {string}\r\n   */\r\n  minf(key) {\r\n    if (this.minify) {\r\n      key.match(/(-\\w[a-zA-Z]+)/g) ? key.match(/(-\\w[a-zA-Z]+)/g).map((current) => {\r\n        if (this.htmlDict.indexOf(current.substring(1, key.length)) === -1) {\r\n          key = key.replace(current.substring(1, key.length), \"t\");\r\n        }\r\n      }) : \"\";\r\n    }\r\n    return key;\r\n  }\r\n\r\n  /**\r\n   * Prepara um container de informações para serem criadas e indexadas.\r\n   * \r\n   * @param {object} data \r\n   * @param {boolean} copy\r\n   * @return {object}\r\n   */\r\n  container(data, copy = false) {\r\n    let newProps = data.props;\r\n    if (Object.keys(data).indexOf('key') !== -1 && data['key'] && !copy) newProps = Object.assign({}, newProps, { key: data.key });\r\n    if (Object.keys(data).indexOf('ref') !== -1 && data['ref']) newProps = Object.assign({}, newProps, { ref: data.ref });\r\n    return this.builder(data.type, newProps ? newProps : null, Object.keys(data.props).indexOf('children') !== -1 ? this.processChildren(data.props.children, copy) : []);\r\n  }\r\n\r\n  /**\r\n   * Processa os filhos de um elemento React para que possam ser mapeados para manipulação.\r\n   * \r\n   * @param {object | array} children \r\n   * @param {boolean} copy\r\n   * @return {object}\r\n   */\r\n  processChildren(children, copy) {\r\n    return children ? children instanceof Array ? children.length > 0 ? children.map(function (arrChild) {\r\n      if (arrChild) return arrChild.type ? this.container(arrChild, copy) : arrChild;\r\n    }, this) : null : children.type ? this.container(children, copy) : children : null;\r\n  }\r\n\r\n  /**\r\n   * Processa um elemento React para que possam ser mapeado para manipulação.\r\n   * \r\n   * @param {object} data \r\n   * @param {string} key \r\n   * @param {boolean} copy\r\n   * @return {object}\r\n   */\r\n  processElement(data, key, copy = false) {\r\n    let obj = this.setStore(key, data, copy);\r\n    this.mapChildrens(obj.props.children, key);\r\n    return this.manipulate(key);\r\n  }\r\n\r\n  /**\r\n   * Mapeia os filhos processados de um elemento para indexação no repositório\r\n   * \r\n   * @param {object} data \r\n   * @param {string} key \r\n   */\r\n  mapChildrens(data, key) {\r\n    if (data) {\r\n      if (data instanceof Array) {\r\n        data.map(function (current, index) {\r\n          if (current) {\r\n            ++index;\r\n            if (current.props) this.mapChildrens(current.props.children, key + '-' + this.haveTypeName(current.type) + index);\r\n            if (current.props) this.putStore(key + '-' + this.haveTypeName(current.type) + index, current.key);\r\n          }\r\n        }, this);\r\n      } else {\r\n        if (data.props) this.mapChildrens(data.props.children, key + '-' + this.haveTypeName(data.type) + '1');\r\n        if (data.props) this.putStore(key + '-' + this.haveTypeName(data.type) + '1', data.key);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verifica se o tipo do componente já foi inserido no dicionário de tipos, caso não exista ele o insere\r\n   * \r\n   * @param {string} type\r\n   * @return {string}\r\n   */\r\n  haveTypeName(type) {\r\n    if (this.minify && typeof type === 'string') {\r\n      if (this.htmlDict.indexOf(type) === -1) this.htmlDict.push(type);\r\n    }\r\n    return type.displayName ? type.displayName : type.name ? type.name : type;\r\n  }\r\n\r\n  /**\r\n   * Recupera um ID único para uso no mapeamento de elementos.\r\n   * @return {string}\r\n   */\r\n  getId() {\r\n    function s4() {\r\n      return Math.floor((1 + Math.random()) * 0x10000)\r\n        .toString(16)\r\n        .substring(1);\r\n    }\r\n    return s4() + s4() + '_' + s4() + '_' + s4() + '_' +\r\n      s4() + '_' + s4() + s4() + s4();\r\n  }\r\n\r\n  /**\r\n   * Insere no repositório um elemento react novo\r\n   * \r\n   * @param {string} key \r\n   * @param {object} jsxData \r\n   * @param {boolean} copy\r\n   * @return {object}\r\n   */\r\n  setStore(key, jsxData, copy = false) {\r\n    return this.putStore(key, this.container(jsxData, copy));\r\n  }\r\n\r\n  /**\r\n   * Recupera um elemento React do repositório e o disponibiliza para manipulação.\r\n   * \r\n   * @param {string} key\r\n   * @return {object}\r\n   */\r\n  manipulate(key) {\r\n    key = this.minf(key);\r\n    return this.checkKey(key) ? new Bridge(key) : '';\r\n  }\r\n\r\n  /**\r\n   * Recupera um elemento React do repositório cria uma cópia com a nova chave e o disponibiliza para manipulação.\r\n   * \r\n   * @param {string} key \r\n   * @param {string} newKey\r\n   * @return {object}\r\n   */\r\n  manipulateCopy(key, newKey) {\r\n    key = this.minf(key);\r\n    return this.manipulate(key).copy(newKey);\r\n  }\r\n\r\n  /**\r\n   * Recupera um elemento do repositório para renderização\r\n   * \r\n   * @param {string} key\r\n   * @return {object}\r\n   */\r\n  getElement(key) {\r\n    key = this.minf(key);\r\n    if (this.checkKey(key)) {\r\n      let temp = this.getStore(key);\r\n      let keyMaster = temp.props ? temp.key : temp;\r\n      let keyArr = key.split('-');\r\n      if (this.checkKey(keyArr[0])) {\r\n        let obj = this.getStore(keyArr[0]);\r\n        return obj.key === keyMaster ? obj : this.walkChildren(obj.props.children, keyMaster);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recupera do repositório e insere um novo Props no elemento relacionado a key informada.\r\n   * \r\n   * @param {string} key \r\n   * @param {object} props \r\n   */\r\n  setProps(key, props) {\r\n\r\n    if (!key && !(props instanceof Object)) {\r\n      console.log('metodo: setProps - Você precisa especificar uma key em string e um props no formato objeto!');\r\n      return;\r\n    }\r\n    if (this.checkKey(key)) {\r\n      let tempJsx = this.getElement(key);\r\n      if (Object.keys(props).indexOf('ref') !== -1) {\r\n        tempJsx = Object.assign({}, tempJsx, { ref: props.ref });\r\n        delete props.ref;\r\n      }\r\n      tempJsx = this.swapPropsAttr(tempJsx, props);\r\n      this.updateAllReferences(tempJsx);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Realiza a descoberta de elementos filhos de um elemento e retorna os elementos encontrados.\r\n   * \r\n   * @param {object} data \r\n   * @param {string} key\r\n   * @return {array}\r\n   */\r\n  walkChildren(data, key) {\r\n    let walk = '';\r\n    if (data) {\r\n      if (data instanceof Array) {\r\n        for (let x = 0; x < data.length; x++) {\r\n          if (data[x]) {\r\n            if (data[x].key === key) return data[x];\r\n            else if (data[x].props) walk = this.walkChildren(data[x].props.children, key);\r\n            if (walk && walk.key === key) return walk;\r\n          }\r\n        }\r\n      } else {\r\n        if (data.key === key) return data;\r\n        else if (data.props) walk = this.walkChildren(data.props.children, key);\r\n        if (walk && walk.key === key) return walk;\r\n      }\r\n    } return;\r\n  }\r\n\r\n  /**\r\n   * Recupera o elemento por meio de sua chave e realiza a cópia do mesmo por meio da nova chave\r\n   * \r\n   * @param {string} key \r\n   * @param {string} keyNew\r\n   * @return {object | undefined} \r\n   */\r\n  copy(key, keyNew) {\r\n    return this.checkKey(key) ? this.processElement(this.getElement(key), keyNew, true) : '';\r\n  }\r\n\r\n  /**\r\n   * Insere um novo atributo no objeto relacionado a chave informada.\r\n   * \r\n   * @param {string} key \r\n   * @param {object} attributes \r\n   */\r\n  setAttribute(key, attributes) {\r\n    if (!key && !attributes || !(attributes instanceof Object)) {\r\n      console.log('metodo: setAttributes - Você precisa especificar uma key em string e um atributo no formato objeto!');\r\n      return;\r\n    }\r\n    if (this.checkKey(key)) {\r\n      if (attributes.ref) {\r\n        let tempJsx = this.getElement(key);\r\n        let updated = Object.assign({}, tempJsx, attributes);\r\n        this.updateAllReferences(updated);\r\n      } else {\r\n        if (this.checkProps(key)) {\r\n          let tempJsx = this.getElement(key);\r\n          let updated = this.swapPropsAttr(tempJsx, attributes);\r\n          this.updateAllReferences(updated);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reaplica um novo valor ao atributo passado ao objeto por meio da chave informada.\r\n   * \r\n   * @param {string} key \r\n   * @param {object} attValues \r\n   */\r\n  modifyAttribute(key, attValues) {\r\n    Object.keys(attValues).map((current) => {\r\n      this.processModify(key, current, attValues[current]);\r\n    }, this);\r\n  }\r\n\r\n  /**\r\n   * Aplica as mudanças nos atributos de acordo com os valores informados.\r\n   * \r\n   * @param {string} key \r\n   * @param {string} atrName \r\n   * @param {*} value \r\n   */\r\n  processModify(key, atrName, value) {\r\n    if (!key && !atrName && !value) {\r\n      console.log('metodo: modifyAttribute - Você precisa especificar a key, o nome do atributo e seu valor por parâmetro!');\r\n      return;\r\n    }\r\n    if (this.checkKey(key)) {\r\n      if (this.checkProps(key)) {\r\n        if (this.checkAttribute(key, atrName) || atrName === 'ref') {\r\n          let tempJsx = this.getElement(key);\r\n          if (atrName === 'ref') {\r\n            let updated = Object.assign({}, tempJsx, { ref: value });\r\n            this.updateAllReferences(updated);\r\n          } else {\r\n            let tempVar = {};\r\n            tempVar[atrName] = value;\r\n            let updated = this.swapPropsAttr(tempJsx, tempVar);\r\n            this.updateAllReferences(updated);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recupera o elemento do repositório e realiza a remoção dos atributos informados\r\n   * \r\n   * @param {string} key \r\n   * @param {array | string} attValues \r\n   */\r\n  removeAttribute(key, attValues) {\r\n    if (attValues instanceof Array) {\r\n      attValues.map((current) => {\r\n        this.processRemove(key, current);\r\n      }, this);\r\n    } else {\r\n      this.processRemove(key, attValues);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Aplica a remoção dos atributos de acordo com os valores informados.\r\n   * \r\n   * @param {string} key \r\n   * @param {string} atrName \r\n   */\r\n  processRemove(key, atrName) {\r\n    if (!key && !atrName) {\r\n      console.log('metodo: removeAttribute - Você precisa especificar uma key em string e o nome do atributo a ser removido!');\r\n      return;\r\n    }\r\n    if (this.checkKey(key)) {\r\n      if (this.checkProps(key)) {\r\n        let tempJsx = this.getElement(key);\r\n        if (atrName === 'ref') {\r\n          let updated = Object.assign({}, tempJsx, { ref: null });\r\n          this.updateAllReferences(updated);\r\n        }\r\n        if (this.checkAttribute(key, atrName)) {\r\n          let index = Object.keys(tempJsx.props);\r\n          index.splice(index.indexOf(atrName), 1);\r\n          let tempObj = {};\r\n          index.map((current) => {\r\n            tempObj[current] = tempJsx.props[current];\r\n          });\r\n          let result = Object.assign({}, tempJsx, { props: tempObj });\r\n          this.updateAllReferences(result);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Realiza a inserção de um elemento filho em um outro elemento especificado pela chave.\r\n   * \r\n   * @param {string} key \r\n   * @param {object} childrenVal \r\n   * @param {integer} index \r\n   * @param {boolean} mergeIndex \r\n   */\r\n  setChildren(key, childrenVal, index = '', mergeIndex = false) {\r\n    if (!key && !childrenVal) {\r\n      console.log('metodo: setChildren - Você precisa especificar a key e um elemento a ser inserido!');\r\n      return;\r\n    }\r\n    if (this.checkKey(key)) {\r\n      let tempJsx = this.getElement(key);\r\n      if (this.checkProps(key)) {\r\n        if (tempJsx.props.children) {\r\n          if (childrenVal instanceof Array) {\r\n            let arrChild = tempJsx.props.children;\r\n            if (!(arrChild instanceof Array)) arrChild = new Array(arrChild);\r\n            let updated = {};\r\n            if (index) {\r\n              index--;\r\n              if (mergeIndex) arrChild.splice(index, 0, ...childrenVal);\r\n              else arrChild.splice(index, 1, ...childrenVal);\r\n              updated = this.swapPropsAttr(tempJsx, { children: arrChild });\r\n            } else updated = this.swapPropsAttr(tempJsx, { children: arrChild.concat(childrenVal) });\r\n            this.updateAllReferences(updated);\r\n          } else {\r\n            let arrChild = tempJsx.props.children instanceof Array ? tempJsx.props.children : new Array(tempJsx.props.children);\r\n            if (index) {\r\n              index--;\r\n              if (mergeIndex) arrChild.splice(index, 0, childrenVal);\r\n              else arrChild[index] = childrenVal;\r\n            } else {\r\n              arrChild.push(childrenVal);\r\n            }\r\n            let updated = this.swapPropsAttr(tempJsx, { children: arrChild });\r\n            this.updateAllReferences(updated);\r\n          }\r\n        } else {\r\n          let updated = this.swapPropsAttr(tempJsx, { children: childrenVal });\r\n          this.updateAllReferences(updated);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recupera um elemento pela chave e realiza a remoção do filho especificado pela indice informado.\r\n   * o indice obedece a regra da ordem dos filhos do elemento pai.\r\n   * \r\n   * @param {string} key \r\n   * @param {intger} index \r\n   */\r\n  removeChildren(key, index) {\r\n    if (index instanceof Array && index !== -1) {\r\n      index.map((current) => {\r\n        this.processRemoveChildren(key, current);\r\n      }, this);\r\n    } else if (index === -1) {\r\n      this.processResetChildren(key);\r\n    } else this.processRemoveChildren(key, index);\r\n  }\r\n\r\n  /**\r\n   * Aplica a remoção do filho de acordo com os valores informados.\r\n   * \r\n   * @param {string} key \r\n   * @param {integer} index \r\n   */\r\n  processRemoveChildren(key, index) {\r\n    index--;\r\n    if (!key && index) {\r\n      console.log('metodo: removeChildren - Você precisa especificar a key onde será retirada a children e o índice que corresponde a children a ser removida!');\r\n      return;\r\n    }\r\n    if (this.checkKey(key)) {\r\n      let jsxMaster = this.getElement(key);\r\n      if (jsxMaster.props.children instanceof Array) {\r\n        let newArr = jsxMaster.props.children.filter((current, idx) => index !== idx);\r\n        let updated = this.swapPropsAttr(jsxMaster, { children: newArr });\r\n        this.updateAllReferences(updated);\r\n      } else {\r\n        let updated = this.swapPropsAttr(jsxMaster, { children: null });\r\n        this.updateAllReferences(updated);\r\n      }\r\n    } else console.log('Chave não encontrada!');\r\n  }\r\n\r\n  /**\r\n   * Remove todos os filhos de um elemento recuperado pela chave.\r\n   * \r\n   * @param {string} key \r\n   */\r\n  processResetChildren(key) {\r\n    if (!key) {\r\n      console.log('metodo: removeChildren - Você precisa especificar a key onde será retirada os childrens !');\r\n      return;\r\n    }\r\n    if (this.checkKey(key)) {\r\n      let jsxMaster = this.getElement(key);\r\n      let updated = this.swapPropsAttr(jsxMaster, { children: null });\r\n      this.updateAllReferences(updated);\r\n    } else console.log('Chave não encontrada!');\r\n  }\r\n\r\n  /**\r\n   * Realiza a atualização das mudanças em todo o repositório\r\n   * \r\n   * @param {object} obj \r\n   */\r\n  updateAllReferences(obj) {\r\n\r\n    let keys = this.keys();\r\n    keys.map(function (current) {\r\n      let tempElement = this.getStore(current);\r\n      if (tempElement.props) {\r\n        if (tempElement.key !== obj.key) {\r\n          let childrenUpdated = this.checkChildrensInArray(obj, tempElement);\r\n          this.putStore(current, this.processElement(this.swapPropsAttr(tempElement, { children: childrenUpdated }), current).getElement());\r\n        } else this.putStore(current, this.processElement(obj, current).getElement());\r\n      }\r\n    }, this);\r\n  }\r\n\r\n  /**\r\n   * Verifica e aplica as mudanças nos filhos de um elemento pai.\r\n   * \r\n   * @param {object} mainElement \r\n   * @param {object} currentElement\r\n   * @return {object} \r\n   */\r\n  checkChildrensInArray(mainElement, currentElement) {\r\n\r\n    if (currentElement && currentElement.props) {\r\n      let childrens = currentElement.props.children;\r\n      let childrenUpdated = [];\r\n      if (childrens && childrens instanceof Array) {\r\n        childrens.map(function (current) {\r\n          let nextChildrens = this.checkChildrensInArray(mainElement, current);\r\n          childrenUpdated = this.compareChildrens(mainElement, current, childrenUpdated, nextChildrens);\r\n        }, this);\r\n        return childrenUpdated;\r\n      } else if (childrens && childrens.props) {\r\n        let nextChildrens = this.checkChildrensInArray(mainElement, childrens);\r\n        childrenUpdated = this.compareChildrens(mainElement, childrens, childrenUpdated, nextChildrens);\r\n        return childrenUpdated;\r\n      } else return childrens;\r\n    } else return currentElement;\r\n  }\r\n\r\n  /**\r\n   * Verifica se houve alteração no filho encontrado e recupera o filho atualizado.\r\n   * \r\n   * @param {object} mainElement \r\n   * @param {object} current \r\n   * @param {object} childrenUpdated \r\n   * @param {object} nextChildrens\r\n   * @return {object}\r\n   */\r\n  compareChildrens(mainElement, current, childrenUpdated, nextChildrens) {\r\n    if (current && current.key && current.key === mainElement.key) {\r\n      childrenUpdated.push(mainElement);\r\n    } else {\r\n      if (current && current.props) childrenUpdated.push(this.swapPropsAttr(current, { children: nextChildrens }));\r\n      else childrenUpdated.push(current);\r\n    }\r\n    return childrenUpdated;\r\n  }\r\n\r\n  /**\r\n   * Realiza a inserção de novos atributos a um elemento informado.\r\n   * \r\n   * @param {object} obj \r\n   * @param {object} newAttr\r\n   * @return {object} \r\n   */\r\n  swapPropsAttr(obj, newAttr) {\r\n    let tempProps = Object.assign({}, obj.props, newAttr);\r\n    return Object.assign({}, obj, { props: tempProps });\r\n  }\r\n\r\n  /**\r\n   * Verifica se existe algum item no repositório relacionado a chave informada.\r\n   * \r\n   * @param {string} key\r\n   * @return {boolean} \r\n   */\r\n  checkKey(key) {\r\n    return this.keys().indexOf(key) === -1 ? false : true;\r\n  }\r\n\r\n  /**\r\n   * Verifica se o elemento relacionado a chave informada contém props.\r\n   * \r\n   * @param {string} key\r\n   * @return {boolean} \r\n   */\r\n  checkProps(key) {\r\n    return this.checkKey(key) ? Object.keys(this.getElement(key)).indexOf('props') === -1 ? false : true : false;\r\n  }\r\n\r\n  /**\r\n   * Verifica se o elemento relacionado a chave informada contém o atributo indicado.\r\n   * \r\n   * @param {string} key \r\n   * @param {string} atrName\r\n   * @return {boolean} \r\n   */\r\n  checkAttribute(key, atrName) {\r\n    return this.checkKey(key) ? this.checkProps(key) ? Object.keys(this.getElement(key).props).indexOf(atrName) === -1 ? false : true : false : false;\r\n  }\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DeathStar.js","import deathStar from './DeathStar';\r\nexport default class Bridge {\r\n  constructor(key) {\r\n    this.instance = deathStar.getInstance();\r\n    this.key = this.instance.minf(key);\r\n  }\r\n  /**\r\n   * Retorna a chave relacionada a manipulação corrente\r\n   * \r\n   * @return {string}\r\n   */\r\n  getMyKey() {\r\n    return this.key;\r\n  }\r\n\r\n  /**\r\n   * Recupera o elemento relacionado a chave deste manipulador para renderização\r\n   * \r\n   * @return {object}\r\n   */\r\n  getElement() {\r\n    return this.instance.getElement(this.key);\r\n  }\r\n\r\n  /**\r\n   * Recupera o elemento relacionado a chave deste manipulador e realiza a cópia do mesmo por meio da nova chave\r\n   * \r\n   * @param {string} newKey\r\n   * @return {object | undefined}\r\n   */\r\n  copy(newKey) {\r\n    return this.instance.copy(this.key, newKey);\r\n  }\r\n\r\n  /**\r\n   * Insere novos atributos no objeto relacionado a chave deste manipulador.\r\n   * Return manipulador\r\n   * \r\n   * @param {object} attributes\r\n   * @return {object}\r\n   */\r\n  setAttribute(attributes) {\r\n    this.instance.setAttribute(this.key, attributes);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Recupera do repositório e insere um novo Props no elemento relacionado a chave deste manipulador.\r\n   * Return manipulador\r\n   * \r\n   * @param {object} props\r\n   * @return {object}\r\n   */\r\n  setProps(props) {\r\n    this.instance.setProps(this.key, props);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Reaplica um novo valor ao atributo passado ao objeto relacionado a chave deste manipulador.\r\n   * Return manipulador\r\n   * \r\n   * @param {object} value\r\n   * @return {object}\r\n   */\r\n  modifyAttribute(value) {\r\n    this.instance.modifyAttribute(this.key, value);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Recupera o elemento do repositório relacionado a chave deste manipulador e realiza a remoção dos atributos informados\r\n   * Return manipulador\r\n   * \r\n   * @param {string} atrName\r\n   * @return {object}\r\n   */\r\n  removeAttribute(atrName) {\r\n    this.instance.removeAttribute(this.key, atrName);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Realiza a inserção de um elemento filho em um outro elemento especificado relacionado a chave deste manipulador.\r\n   * Return manipulador\r\n   * \r\n   * @param {object} children \r\n   * @param {integer} index \r\n   * @param {boolean} mergeIndex\r\n   * @return {object}\r\n   */\r\n  setChildren(children, index = '', mergeIndex = false) {\r\n    this.instance.setChildren(this.key, children, index, mergeIndex);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Recupera um elemento relacionado a chave deste manipulador e realiza a remoção do filho especificado pela índice informado.\r\n   * o índice obedece a regra da ordem dos filhos do elemento pai.\r\n   * Return manipulador\r\n   * \r\n   * @param {integer} index\r\n   * @return {object}\r\n   */\r\n  removeChildren(index) {\r\n    this.instance.removeChildren(this.key, index);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Verifica se o elemento relacionado a chave deste manipulador contém o atributo indicado.\r\n   * \r\n   * @param {string} atrName\r\n   * @return {boolean} \r\n   */\r\n  checkAttribute(atrName) {\r\n    return this.instance.checkAttribute(this.key, atrName);\r\n  }\r\n\r\n  /**\r\n   * Recupera o elemento React relacionado a chave deste manipulador, cria uma cópia com a nova chave e o disponibiliza para manipulação.\r\n   * \r\n   * @param {string} newKey\r\n   * @return {object}\r\n   */\r\n  manipulateCopy(newKey) {\r\n    return this.instance.manipulateCopy(this.key, newKey);\r\n  }\r\n\r\n  /**\r\n   * Carrega este manipulador de elemento com a nova chave informada\r\n   * Return manipulador\r\n   * \r\n   * @param {string} key \r\n   * @return {object}\r\n   */\r\n  manipulate(key) {\r\n    this.key = this.instance.minf(key);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Destrói os elementos React do repositório por meio da lista de Arrays informados.\r\n   * Return manipulador\r\n   * \r\n   * @param {array | string} keys\r\n   * @return {object}\r\n   */\r\n  destroy(keys) {\r\n    this.instance.destroy(keys);\r\n    return this;\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Bridge.js","var ninf = {\r\n  minify: true\r\n};\r\n\r\nmodule.exports = ninf;\r\n\n\n\n// WEBPACK FOOTER //\n// ./minify.conf.js"],"sourceRoot":""}