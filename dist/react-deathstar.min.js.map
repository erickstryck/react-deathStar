{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-deathstar.min.js","webpack:///webpack/bootstrap 97e83ab6b659dae00ee0","webpack:///./src/index.js","webpack:///./src/DeathStar.js","webpack:///./src/Bridge.js","webpack:///./minify.conf.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_DeathStar","_DeathStar2","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_Bridge","_Bridge2","_minify","_minify2","DeathStar","react","createElement","storage","setStore","bind","checkKey","htmlDict","minify","minf","builder","putStore","getStore","deleteStore","keys","type","children","assign","indexOf","getId","context","forceUpdate","temp","map","current","state","_this","store","currentItem","currentStore","split","_this2","match","substring","replace","data","copy","arguments","undefined","newProps","ref","processChildren","arrChild","container","mapChildrens","manipulate","index","haveTypeName","push","displayName","name","s4","Math","floor","random","toString","jsxData","newKey","keyMaster","keyArr","walkChildren","console","log","tempJsx","getElement","swapPropsAttr","updateAllReferences","walk","x","keyNew","processElement","attributes","updated","checkProps","attValues","_this3","processModify","atrName","checkAttribute","tempVar","_this4","processRemove","splice","tempObj","result","childrenVal","mergeIndex","_arrChild","_arrChild2","apply","concat","_this5","processRemoveChildren","processResetChildren","jsxMaster","newArr","filter","idx","tempElement","childrenUpdated","checkChildrensInArray","mainElement","currentElement","childrens","nextChildrens","compareChildrens","newAttr","tempProps","Bridge","getInstance","setAttribute","setProps","modifyAttribute","removeAttribute","setChildren","removeChildren","manipulateCopy","destroy","ninf"],"mappings":"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","file":"react-deathstar.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"react-deathstar\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"react-deathstar\"] = factory();\n\telse\n\t\troot[\"react-deathstar\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"react-deathstar\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"react-deathstar\"] = factory();\n\telse\n\t\troot[\"react-deathstar\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _DeathStar = __webpack_require__(1);\n\t\n\tvar _DeathStar2 = _interopRequireDefault(_DeathStar);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = _DeathStar2.default;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Bridge = __webpack_require__(2);\n\t\n\tvar _Bridge2 = _interopRequireDefault(_Bridge);\n\t\n\tvar _minify = __webpack_require__(3);\n\t\n\tvar _minify2 = _interopRequireDefault(_minify);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar instance = '';\n\t\n\tvar DeathStar = function () {\n\t\n\t  /**\r\n\t   * Construtor da classe\r\n\t   * \r\n\t   * @param {object} react \r\n\t   */\n\t  function DeathStar(react) {\n\t    _classCallCheck(this, DeathStar);\n\t\n\t    this.createElement = react.createElement;\n\t    this.storage = {};\n\t    this.setStore.bind(this);\n\t    this.checkKey.bind(this);\n\t    this.htmlDict = [];\n\t    this.minify = _minify2.default.minify;\n\t    this.minf.bind(this);\n\t    this.builder.bind(this);\n\t    this.putStore.bind(this);\n\t    this.getStore.bind(this);\n\t    this.deleteStore.bind(this);\n\t    this.keys.bind(this);\n\t  }\n\t\n\t  /**\r\n\t   * Recupera a instancia corrente do react pelo componente que o utilizará\r\n\t   * \r\n\t   * @param {object} react\r\n\t   * @return {object}\r\n\t   */\n\t\n\t\n\t  _createClass(DeathStar, [{\n\t    key: 'builder',\n\t\n\t\n\t    /**\r\n\t     * Recria o componente informado com seu devido mapeamento para manipulação\r\n\t     * \r\n\t     * @param {string | object} type \r\n\t     * @param {object} props \r\n\t     * @param {object} children\r\n\t     * @return {object}\r\n\t     */\n\t    value: function builder(type, props, children) {\n\t      if (children && children.length === 0) children = null;\n\t      props = props.children ? Object.assign({}, props, { children: null }) : props;\n\t      props = Object.keys(props).indexOf('key') !== -1 ? Object.assign({}, props, { key: props.key }) : Object.assign({}, props, { key: this.getId() });\n\t      return this.createElement(type, props, children);\n\t    }\n\t\n\t    /**\r\n\t     * Limpa o repositório local de informações\r\n\t     */\n\t\n\t  }, {\n\t    key: 'clearBus',\n\t    value: function clearBus() {\n\t      this.storage = {};\n\t    }\n\t\n\t    /**\r\n\t     * Persiste os dados informados no repositório local\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {object} value \r\n\t     * @param {object} context\r\n\t     * @return {object | undefined}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'putStore',\n\t    value: function putStore(key, value, context) {\n\t      if (context) {\n\t        value['deathStartUpdater'] = function () {\n\t          value.forceUpdate();\n\t        };\n\t        var temp = {};\n\t        Object.keys(value).map(function (current) {\n\t          if (typeof value[current] === 'function') {\n\t            temp[current] = value[current];\n\t          }\n\t        });\n\t        temp['state'] = value.state;\n\t        this.storage[key] = temp;\n\t      } else {\n\t        this.storage[key] = value;\n\t        return value;\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Recupera o dado do repositório por meio da 'Key' informada \r\n\t     * \r\n\t     * @param {string} key\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'getStore',\n\t    value: function getStore(key) {\n\t      return this.storage[key];\n\t    }\n\t\n\t    /**\r\n\t     * Remove o objeto do repositório por meio da 'Key' informada\r\n\t     * \r\n\t     * @param {string} key \r\n\t     */\n\t\n\t  }, {\n\t    key: 'deleteStore',\n\t    value: function deleteStore(key) {\n\t      delete this.storage[key];\n\t    }\n\t\n\t    /**\r\n\t     * Recupera todas as chaves realcionadas aos objetos persistidos no repositório\r\n\t     * @return {array}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'keys',\n\t    value: function keys() {\n\t      return Object.keys(this.storage);\n\t    }\n\t\n\t    /**\r\n\t     * Destrói os elementos React do repositório por meio da lista de Arrays informados.\r\n\t     * \r\n\t     * @param {array | string} keys \r\n\t     */\n\t\n\t  }, {\n\t    key: 'destroy',\n\t    value: function destroy(keys) {\n\t      var _this = this;\n\t\n\t      if (keys instanceof Array) {\n\t        var store = this.keys();\n\t        keys.map(function (currentItem) {\n\t          store.map(function (currentStore) {\n\t            if (currentStore.split('-')[0] === currentItem) {\n\t              _this.deleteStore(currentItem);\n\t            }\n\t          }, _this);\n\t        }, this);\n\t      } else {\n\t        var _store = this.keys();\n\t        _store.map(function (currentStore) {\n\t          if (currentStore.split('-')[0] === keys) {\n\t            _this.deleteStore(currentStore);\n\t          }\n\t        }, this);\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Realiza a minificação dos tipos de objetos React fazendo a compressão de nomes dos componentes.\r\n\t     * \r\n\t     * @param {string} key\r\n\t     * @return {string}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'minf',\n\t    value: function minf(key) {\n\t      var _this2 = this;\n\t\n\t      if (this.minify) {\n\t        key.match(/(-\\w[a-zA-Z]+)/g) ? key.match(/(-\\w[a-zA-Z]+)/g).map(function (current) {\n\t          if (_this2.htmlDict.indexOf(current.substring(1, key.length)) === -1) {\n\t            key = key.replace(current.substring(1, key.length), \"t\");\n\t          }\n\t        }) : \"\";\n\t      }\n\t      return key;\n\t    }\n\t\n\t    /**\r\n\t     * Prepara um container de informações para serem criadas e indexadas.\r\n\t     * \r\n\t     * @param {object} data \r\n\t     * @param {boolean} copy\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'container',\n\t    value: function container(data) {\n\t      var copy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t      var newProps = data.props;\n\t      if (Object.keys(data).indexOf('key') !== -1 && data['key'] && !copy) newProps = Object.assign({}, newProps, { key: data.key });\n\t      if (Object.keys(data).indexOf('ref') !== -1 && data['ref']) newProps = Object.assign({}, newProps, { ref: data.ref });\n\t      return this.builder(data.type, newProps ? newProps : null, Object.keys(data.props).indexOf('children') !== -1 ? this.processChildren(data.props.children, copy) : []);\n\t    }\n\t\n\t    /**\r\n\t     * Processa os filhos de um elemento React para que possam ser mapeados para manipulação.\r\n\t     * \r\n\t     * @param {object | array} children \r\n\t     * @param {boolean} copy\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'processChildren',\n\t    value: function processChildren(children, copy) {\n\t      return children ? children instanceof Array ? children.length > 0 ? children.map(function (arrChild) {\n\t        if (arrChild) return arrChild.type ? this.container(arrChild, copy) : arrChild;\n\t      }, this) : null : children.type ? this.container(children, copy) : children : null;\n\t    }\n\t\n\t    /**\r\n\t     * Processa um elemento React para que possam ser mapeado para manipulação.\r\n\t     * \r\n\t     * @param {object} data \r\n\t     * @param {string} key \r\n\t     * @param {boolean} copy\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'processElement',\n\t    value: function processElement(data, key) {\n\t      var copy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      var obj = this.setStore(key, data, copy);\n\t      this.mapChildrens(obj.props.children, key);\n\t      return this.manipulate(key);\n\t    }\n\t\n\t    /**\r\n\t     * Mapeia os filhos processados de um elemento para indexação no repositório\r\n\t     * \r\n\t     * @param {object} data \r\n\t     * @param {string} key \r\n\t     */\n\t\n\t  }, {\n\t    key: 'mapChildrens',\n\t    value: function mapChildrens(data, key) {\n\t      if (data) {\n\t        if (data instanceof Array) {\n\t          data.map(function (current, index) {\n\t            if (current) {\n\t              ++index;\n\t              if (current.props) this.mapChildrens(current.props.children, key + '-' + this.haveTypeName(current.type) + index);\n\t              if (current.props) this.putStore(key + '-' + this.haveTypeName(current.type) + index, current.key);\n\t            }\n\t          }, this);\n\t        } else {\n\t          if (data.props) this.mapChildrens(data.props.children, key + '-' + this.haveTypeName(data.type) + '1');\n\t          if (data.props) this.putStore(key + '-' + this.haveTypeName(data.type) + '1', data.key);\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Verifica se o tipo do componente já foi inserido no dicionário de tipos, caso não exista ele o insere\r\n\t     * \r\n\t     * @param {string} type\r\n\t     * @return {string}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'haveTypeName',\n\t    value: function haveTypeName(type) {\n\t      if (this.minify && typeof type === 'string') {\n\t        if (this.htmlDict.indexOf(type) === -1) this.htmlDict.push(type);\n\t      }\n\t      return type.displayName ? type.displayName : type.name ? type.name : type;\n\t    }\n\t\n\t    /**\r\n\t     * Recupera um ID único para uso no mapeamento de elementos.\r\n\t     * @return {string}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'getId',\n\t    value: function getId() {\n\t      function s4() {\n\t        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n\t      }\n\t      return s4() + s4() + '_' + s4() + '_' + s4() + '_' + s4() + '_' + s4() + s4() + s4();\n\t    }\n\t\n\t    /**\r\n\t     * Insere no repositório um elemento react novo\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {object} jsxData \r\n\t     * @param {boolean} copy\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'setStore',\n\t    value: function setStore(key, jsxData) {\n\t      var copy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      return this.putStore(key, this.container(jsxData, copy));\n\t    }\n\t\n\t    /**\r\n\t     * Recupera um elemento React do repositório e o disponibiliza para manipulação.\r\n\t     * \r\n\t     * @param {string} key\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'manipulate',\n\t    value: function manipulate(key) {\n\t      key = this.minf(key);\n\t      return this.checkKey(key) ? new _Bridge2.default(key) : '';\n\t    }\n\t\n\t    /**\r\n\t     * Recupera um elemento React do repositório cria uma cópia com a nova chave e o disponibiliza para manipulação.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {string} newKey\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'manipulateCopy',\n\t    value: function manipulateCopy(key, newKey) {\n\t      key = this.minf(key);\n\t      return this.manipulate(key).copy(newKey);\n\t    }\n\t\n\t    /**\r\n\t     * Recupera um elemento do repositório para renderização\r\n\t     * \r\n\t     * @param {string} key\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'getElement',\n\t    value: function getElement(key) {\n\t      key = this.minf(key);\n\t      if (this.checkKey(key)) {\n\t        var temp = this.getStore(key);\n\t        var keyMaster = temp.props ? temp.key : temp;\n\t        var keyArr = key.split('-');\n\t        if (this.checkKey(keyArr[0])) {\n\t          var obj = this.getStore(keyArr[0]);\n\t          return obj.key === keyMaster ? obj : this.walkChildren(obj.props.children, keyMaster);\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Recupera do repositório e insere um novo Props no elemento relacionado a key informada.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {object} props \r\n\t     */\n\t\n\t  }, {\n\t    key: 'setProps',\n\t    value: function setProps(key, props) {\n\t\n\t      if (!key && !(props instanceof Object)) {\n\t        console.log('metodo: setProps - Você precisa especificar uma key em string e um props no formato objeto!');\n\t        return;\n\t      }\n\t      if (this.checkKey(key)) {\n\t        var tempJsx = this.getElement(key);\n\t        if (Object.keys(props).indexOf('ref') !== -1) {\n\t          tempJsx = Object.assign({}, tempJsx, { ref: props.ref });\n\t          delete props.ref;\n\t        }\n\t        tempJsx = this.swapPropsAttr(tempJsx, props);\n\t        this.updateAllReferences(tempJsx);\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Realiza a descoberta de elementos filhos de um elemento e retorna os elementos encontrados.\r\n\t     * \r\n\t     * @param {object} data \r\n\t     * @param {string} key\r\n\t     * @return {array}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'walkChildren',\n\t    value: function walkChildren(data, key) {\n\t      var walk = '';\n\t      if (data) {\n\t        if (data instanceof Array) {\n\t          for (var x = 0; x < data.length; x++) {\n\t            if (data[x]) {\n\t              if (data[x].key === key) return data[x];else if (data[x].props) walk = this.walkChildren(data[x].props.children, key);\n\t              if (walk && walk.key === key) return walk;\n\t            }\n\t          }\n\t        } else {\n\t          if (data.key === key) return data;else if (data.props) walk = this.walkChildren(data.props.children, key);\n\t          if (walk && walk.key === key) return walk;\n\t        }\n\t      }return;\n\t    }\n\t\n\t    /**\r\n\t     * Recupera o elemento por meio de sua chave e realiza a cópia do mesmo por meio da nova chave\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {string} keyNew\r\n\t     * @return {object | undefined} \r\n\t     */\n\t\n\t  }, {\n\t    key: 'copy',\n\t    value: function copy(key, keyNew) {\n\t      return this.checkKey(key) ? this.processElement(this.getElement(key), keyNew, true) : '';\n\t    }\n\t\n\t    /**\r\n\t     * Insere um novo atributo no objeto relacionado a chave informada.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {object} attributes \r\n\t     */\n\t\n\t  }, {\n\t    key: 'setAttribute',\n\t    value: function setAttribute(key, attributes) {\n\t      if (!key && !attributes || !(attributes instanceof Object)) {\n\t        console.log('metodo: setAttributes - Você precisa especificar uma key em string e um atributo no formato objeto!');\n\t        return;\n\t      }\n\t      if (this.checkKey(key)) {\n\t        if (attributes.ref) {\n\t          var tempJsx = this.getElement(key);\n\t          var updated = Object.assign({}, tempJsx, attributes);\n\t          this.updateAllReferences(updated);\n\t        } else {\n\t          if (this.checkProps(key)) {\n\t            var _tempJsx = this.getElement(key);\n\t            var _updated = this.swapPropsAttr(_tempJsx, attributes);\n\t            this.updateAllReferences(_updated);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Reaplica um novo valor ao atributo passado ao objeto por meio da chave informada.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {object} attValues \r\n\t     */\n\t\n\t  }, {\n\t    key: 'modifyAttribute',\n\t    value: function modifyAttribute(key, attValues) {\n\t      var _this3 = this;\n\t\n\t      Object.keys(attValues).map(function (current) {\n\t        _this3.processModify(key, current, attValues[current]);\n\t      }, this);\n\t    }\n\t\n\t    /**\r\n\t     * Aplica as mudanças nos atributos de acordo com os valores informados.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {string} atrName \r\n\t     * @param {*} value \r\n\t     */\n\t\n\t  }, {\n\t    key: 'processModify',\n\t    value: function processModify(key, atrName, value) {\n\t      if (!key && !atrName && !value) {\n\t        console.log('metodo: modifyAttribute - Você precisa especificar a key, o nome do atributo e seu valor por parâmetro!');\n\t        return;\n\t      }\n\t      if (this.checkKey(key)) {\n\t        if (this.checkProps(key)) {\n\t          if (this.checkAttribute(key, atrName) || atrName === 'ref') {\n\t            var tempJsx = this.getElement(key);\n\t            if (atrName === 'ref') {\n\t              var updated = Object.assign({}, tempJsx, { ref: value });\n\t              this.updateAllReferences(updated);\n\t            } else {\n\t              var tempVar = {};\n\t              tempVar[atrName] = value;\n\t              var _updated2 = this.swapPropsAttr(tempJsx, tempVar);\n\t              this.updateAllReferences(_updated2);\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Recupera o elemento do repositório e realiza a remoção dos atributos informados\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {array | string} attValues \r\n\t     */\n\t\n\t  }, {\n\t    key: 'removeAttribute',\n\t    value: function removeAttribute(key, attValues) {\n\t      var _this4 = this;\n\t\n\t      if (attValues instanceof Array) {\n\t        attValues.map(function (current) {\n\t          _this4.processRemove(key, current);\n\t        }, this);\n\t      } else {\n\t        this.processRemove(key, attValues);\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Aplica a remoção dos atributos de acordo com os valores informados.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {string} atrName \r\n\t     */\n\t\n\t  }, {\n\t    key: 'processRemove',\n\t    value: function processRemove(key, atrName) {\n\t      if (!key && !atrName) {\n\t        console.log('metodo: removeAttribute - Você precisa especificar uma key em string e o nome do atributo a ser removido!');\n\t        return;\n\t      }\n\t      if (this.checkKey(key)) {\n\t        if (this.checkProps(key)) {\n\t          var tempJsx = this.getElement(key);\n\t          if (atrName === 'ref') {\n\t            var updated = Object.assign({}, tempJsx, { ref: null });\n\t            this.updateAllReferences(updated);\n\t          }\n\t          if (this.checkAttribute(key, atrName)) {\n\t            var index = Object.keys(tempJsx.props);\n\t            index.splice(index.indexOf(atrName), 1);\n\t            var tempObj = {};\n\t            index.map(function (current) {\n\t              tempObj[current] = tempJsx.props[current];\n\t            });\n\t            var result = Object.assign({}, tempJsx, { props: tempObj });\n\t            this.updateAllReferences(result);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Realiza a inserção de um elemento filho em um outro elemento especificado pela chave.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {object} childrenVal \r\n\t     * @param {integer} index \r\n\t     * @param {boolean} mergeIndex \r\n\t     */\n\t\n\t  }, {\n\t    key: 'setChildren',\n\t    value: function setChildren(key, childrenVal) {\n\t      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\t      var mergeIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\t\n\t      if (!key && !childrenVal) {\n\t        console.log('metodo: setChildren - Você precisa especificar a key e um elemento a ser inserido!');\n\t        return;\n\t      }\n\t      if (this.checkKey(key)) {\n\t        var tempJsx = this.getElement(key);\n\t        if (this.checkProps(key)) {\n\t          if (tempJsx.props.children) {\n\t            if (childrenVal instanceof Array) {\n\t              var arrChild = tempJsx.props.children;\n\t              if (!(arrChild instanceof Array)) arrChild = new Array(arrChild);\n\t              var updated = {};\n\t              if (index) {\n\t                var _arrChild, _arrChild2;\n\t\n\t                index--;\n\t                if (mergeIndex) (_arrChild = arrChild).splice.apply(_arrChild, [index, 0].concat(_toConsumableArray(childrenVal)));else (_arrChild2 = arrChild).splice.apply(_arrChild2, [index, 1].concat(_toConsumableArray(childrenVal)));\n\t                updated = this.swapPropsAttr(tempJsx, { children: arrChild });\n\t              } else updated = this.swapPropsAttr(tempJsx, { children: arrChild.concat(childrenVal) });\n\t              this.updateAllReferences(updated);\n\t            } else {\n\t              var _arrChild3 = tempJsx.props.children instanceof Array ? tempJsx.props.children : new Array(tempJsx.props.children);\n\t              if (index) {\n\t                index--;\n\t                if (mergeIndex) _arrChild3.splice(index, 0, childrenVal);else _arrChild3[index] = childrenVal;\n\t              } else {\n\t                _arrChild3.push(childrenVal);\n\t              }\n\t              var _updated3 = this.swapPropsAttr(tempJsx, { children: _arrChild3 });\n\t              this.updateAllReferences(_updated3);\n\t            }\n\t          } else {\n\t            var _updated4 = this.swapPropsAttr(tempJsx, { children: childrenVal });\n\t            this.updateAllReferences(_updated4);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Recupera um elemento pela chave e realiza a remoção do filho especificado pela indice informado.\r\n\t     * o indice obedece a regra da ordem dos filhos do elemento pai.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {intger} index \r\n\t     */\n\t\n\t  }, {\n\t    key: 'removeChildren',\n\t    value: function removeChildren(key, index) {\n\t      var _this5 = this;\n\t\n\t      if (index instanceof Array && index !== -1) {\n\t        index.map(function (current) {\n\t          _this5.processRemoveChildren(key, current);\n\t        }, this);\n\t      } else if (index === -1) {\n\t        this.processResetChildren(key);\n\t      } else this.processRemoveChildren(key, index);\n\t    }\n\t\n\t    /**\r\n\t     * Aplica a remoção do filho de acordo com os valores informados.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {integer} index \r\n\t     */\n\t\n\t  }, {\n\t    key: 'processRemoveChildren',\n\t    value: function processRemoveChildren(key, index) {\n\t      index--;\n\t      if (!key && index) {\n\t        console.log('metodo: removeChildren - Você precisa especificar a key onde será retirada a children e o índice que corresponde a children a ser removida!');\n\t        return;\n\t      }\n\t      if (this.checkKey(key)) {\n\t        var jsxMaster = this.getElement(key);\n\t        if (jsxMaster.props.children instanceof Array) {\n\t          var newArr = jsxMaster.props.children.filter(function (current, idx) {\n\t            return index !== idx;\n\t          });\n\t          var updated = this.swapPropsAttr(jsxMaster, { children: newArr });\n\t          this.updateAllReferences(updated);\n\t        } else {\n\t          var _updated5 = this.swapPropsAttr(jsxMaster, { children: null });\n\t          this.updateAllReferences(_updated5);\n\t        }\n\t      } else console.log('Chave não encontrada!');\n\t    }\n\t\n\t    /**\r\n\t     * Remove todos os filhos de um elemento recuperado pela chave.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     */\n\t\n\t  }, {\n\t    key: 'processResetChildren',\n\t    value: function processResetChildren(key) {\n\t      if (!key) {\n\t        console.log('metodo: removeChildren - Você precisa especificar a key onde será retirada os childrens !');\n\t        return;\n\t      }\n\t      if (this.checkKey(key)) {\n\t        var jsxMaster = this.getElement(key);\n\t        var updated = this.swapPropsAttr(jsxMaster, { children: null });\n\t        this.updateAllReferences(updated);\n\t      } else console.log('Chave não encontrada!');\n\t    }\n\t\n\t    /**\r\n\t     * Realiza a atualização das mudanças em todo o repositório\r\n\t     * \r\n\t     * @param {object} obj \r\n\t     */\n\t\n\t  }, {\n\t    key: 'updateAllReferences',\n\t    value: function updateAllReferences(obj) {\n\t\n\t      var keys = this.keys();\n\t      keys.map(function (current) {\n\t        var tempElement = this.getStore(current);\n\t        if (tempElement.props) {\n\t          if (tempElement.key !== obj.key) {\n\t            var childrenUpdated = this.checkChildrensInArray(obj, tempElement);\n\t            this.putStore(current, this.processElement(this.swapPropsAttr(tempElement, { children: childrenUpdated }), current).getElement());\n\t          } else this.putStore(current, this.processElement(obj, current).getElement());\n\t        }\n\t      }, this);\n\t    }\n\t\n\t    /**\r\n\t     * Verifica e aplica as mudanças nos filhos de um elemento pai.\r\n\t     * \r\n\t     * @param {object} mainElement \r\n\t     * @param {object} currentElement\r\n\t     * @return {object} \r\n\t     */\n\t\n\t  }, {\n\t    key: 'checkChildrensInArray',\n\t    value: function checkChildrensInArray(mainElement, currentElement) {\n\t\n\t      if (currentElement && currentElement.props) {\n\t        var childrens = currentElement.props.children;\n\t        var childrenUpdated = [];\n\t        if (childrens && childrens instanceof Array) {\n\t          childrens.map(function (current) {\n\t            var nextChildrens = this.checkChildrensInArray(mainElement, current);\n\t            childrenUpdated = this.compareChildrens(mainElement, current, childrenUpdated, nextChildrens);\n\t          }, this);\n\t          return childrenUpdated;\n\t        } else if (childrens && childrens.props) {\n\t          var nextChildrens = this.checkChildrensInArray(mainElement, childrens);\n\t          childrenUpdated = this.compareChildrens(mainElement, childrens, childrenUpdated, nextChildrens);\n\t          return childrenUpdated;\n\t        } else return childrens;\n\t      } else return currentElement;\n\t    }\n\t\n\t    /**\r\n\t     * Verifica se houve alteração no filho encontrado e recupera o filho atualizado.\r\n\t     * \r\n\t     * @param {object} mainElement \r\n\t     * @param {object} current \r\n\t     * @param {object} childrenUpdated \r\n\t     * @param {object} nextChildrens\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'compareChildrens',\n\t    value: function compareChildrens(mainElement, current, childrenUpdated, nextChildrens) {\n\t      if (current && current.key && current.key === mainElement.key) {\n\t        childrenUpdated.push(mainElement);\n\t      } else {\n\t        if (current && current.props) childrenUpdated.push(this.swapPropsAttr(current, { children: nextChildrens }));else childrenUpdated.push(current);\n\t      }\n\t      return childrenUpdated;\n\t    }\n\t\n\t    /**\r\n\t     * Realiza a inserção de novos atributos a um elemento informado.\r\n\t     * \r\n\t     * @param {object} obj \r\n\t     * @param {object} newAttr\r\n\t     * @return {object} \r\n\t     */\n\t\n\t  }, {\n\t    key: 'swapPropsAttr',\n\t    value: function swapPropsAttr(obj, newAttr) {\n\t      var tempProps = Object.assign({}, obj.props, newAttr);\n\t      return Object.assign({}, obj, { props: tempProps });\n\t    }\n\t\n\t    /**\r\n\t     * Verifica se existe algum item no repositório relacionado a chave informada.\r\n\t     * \r\n\t     * @param {string} key\r\n\t     * @return {boolean} \r\n\t     */\n\t\n\t  }, {\n\t    key: 'checkKey',\n\t    value: function checkKey(key) {\n\t      return this.keys().indexOf(key) === -1 ? false : true;\n\t    }\n\t\n\t    /**\r\n\t     * Verifica se o elemento relacionado a chave informada contém props.\r\n\t     * \r\n\t     * @param {string} key\r\n\t     * @return {boolean} \r\n\t     */\n\t\n\t  }, {\n\t    key: 'checkProps',\n\t    value: function checkProps(key) {\n\t      return this.checkKey(key) ? Object.keys(this.getElement(key)).indexOf('props') === -1 ? false : true : false;\n\t    }\n\t\n\t    /**\r\n\t     * Verifica se o elemento relacionado a chave informada contém o atributo indicado.\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @param {string} atrName\r\n\t     * @return {boolean} \r\n\t     */\n\t\n\t  }, {\n\t    key: 'checkAttribute',\n\t    value: function checkAttribute(key, atrName) {\n\t      return this.checkKey(key) ? this.checkProps(key) ? Object.keys(this.getElement(key).props).indexOf(atrName) === -1 ? false : true : false : false;\n\t    }\n\t  }], [{\n\t    key: 'getInstance',\n\t    value: function getInstance(react) {\n\t      if (instance) {\n\t        return instance;\n\t      } else {\n\t        instance = new DeathStar(react);\n\t        return instance;\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return DeathStar;\n\t}();\n\t\n\texports.default = DeathStar;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _DeathStar = __webpack_require__(1);\n\t\n\tvar _DeathStar2 = _interopRequireDefault(_DeathStar);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Bridge = function () {\n\t  function Bridge(key) {\n\t    _classCallCheck(this, Bridge);\n\t\n\t    this.instance = _DeathStar2.default.getInstance();\n\t    this.key = this.instance.minf(key);\n\t  }\n\t  /**\r\n\t   * Retorna a chave relacionada a manipulação corrente\r\n\t   * \r\n\t   * @return {string}\r\n\t   */\n\t\n\t\n\t  _createClass(Bridge, [{\n\t    key: 'getMyKey',\n\t    value: function getMyKey() {\n\t      return this.key;\n\t    }\n\t\n\t    /**\r\n\t     * Recupera o elemento relacionado a chave deste manipulador para renderização\r\n\t     * \r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'getElement',\n\t    value: function getElement() {\n\t      return this.instance.getElement(this.key);\n\t    }\n\t\n\t    /**\r\n\t     * Recupera o elemento relacionado a chave deste manipulador e realiza a cópia do mesmo por meio da nova chave\r\n\t     * \r\n\t     * @param {string} newKey\r\n\t     * @return {object | undefined}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'copy',\n\t    value: function copy(newKey) {\n\t      return this.instance.copy(this.key, newKey);\n\t    }\n\t\n\t    /**\r\n\t     * Insere novos atributos no objeto relacionado a chave deste manipulador.\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {object} attributes\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'setAttribute',\n\t    value: function setAttribute(attributes) {\n\t      this.instance.setAttribute(this.key, attributes);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Recupera do repositório e insere um novo Props no elemento relacionado a chave deste manipulador.\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {object} props\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'setProps',\n\t    value: function setProps(props) {\n\t      this.instance.setProps(this.key, props);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Reaplica um novo valor ao atributo passado ao objeto relacionado a chave deste manipulador.\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {object} value\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'modifyAttribute',\n\t    value: function modifyAttribute(value) {\n\t      this.instance.modifyAttribute(this.key, value);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Recupera o elemento do repositório relacionado a chave deste manipulador e realiza a remoção dos atributos informados\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {string} atrName\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'removeAttribute',\n\t    value: function removeAttribute(atrName) {\n\t      this.instance.removeAttribute(this.key, atrName);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Realiza a inserção de um elemento filho em um outro elemento especificado relacionado a chave deste manipulador.\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {object} children \r\n\t     * @param {integer} index \r\n\t     * @param {boolean} mergeIndex\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'setChildren',\n\t    value: function setChildren(children) {\n\t      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\t      var mergeIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      this.instance.setChildren(this.key, children, index, mergeIndex);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Recupera um elemento relacionado a chave deste manipulador e realiza a remoção do filho especificado pela índice informado.\r\n\t     * o índice obedece a regra da ordem dos filhos do elemento pai.\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {integer} index\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'removeChildren',\n\t    value: function removeChildren(index) {\n\t      this.instance.removeChildren(this.key, index);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Verifica se o elemento relacionado a chave deste manipulador contém o atributo indicado.\r\n\t     * \r\n\t     * @param {string} atrName\r\n\t     * @return {boolean} \r\n\t     */\n\t\n\t  }, {\n\t    key: 'checkAttribute',\n\t    value: function checkAttribute(atrName) {\n\t      return this.instance.checkAttribute(this.key, atrName);\n\t    }\n\t\n\t    /**\r\n\t     * Recupera o elemento React relacionado a chave deste manipulador, cria uma cópia com a nova chave e o disponibiliza para manipulação.\r\n\t     * \r\n\t     * @param {string} newKey\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'manipulateCopy',\n\t    value: function manipulateCopy(newKey) {\n\t      return this.instance.manipulateCopy(this.key, newKey);\n\t    }\n\t\n\t    /**\r\n\t     * Carrega este manipulador de elemento com a nova chave informada\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {string} key \r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'manipulate',\n\t    value: function manipulate(key) {\n\t      this.key = this.instance.minf(key);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Destrói os elementos React do repositório por meio da lista de Arrays informados.\r\n\t     * Return manipulador\r\n\t     * \r\n\t     * @param {array | string} keys\r\n\t     * @return {object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'destroy',\n\t    value: function destroy(keys) {\n\t      this.instance.destroy(keys);\n\t      return this;\n\t    }\n\t  }]);\n\t\n\t  return Bridge;\n\t}();\n\t\n\texports.default = Bridge;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tvar ninf = {\n\t  minify: true\n\t};\n\t\n\tmodule.exports = ninf;\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// react-deathstar.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 97e83ab6b659dae00ee0","import DeathStar from './DeathStar';\r\nexport default DeathStar;\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import Bridge from './Bridge';\r\nimport ninf from '../minify.conf';\r\n\r\nlet instance = '';\r\n\r\nexport default class DeathStar {\r\n\r\n  /**\r\n   * Construtor da classe\r\n   * \r\n   * @param {object} react \r\n   */\r\n  constructor(react) {\r\n    this.createElement = react.createElement;\r\n    this.storage = {};\r\n    this.setStore.bind(this);\r\n    this.checkKey.bind(this);\r\n    this.htmlDict = [];\r\n    this.minify = ninf.minify;\r\n    this.minf.bind(this);\r\n    this.builder.bind(this);\r\n    this.putStore.bind(this);\r\n    this.getStore.bind(this);\r\n    this.deleteStore.bind(this);\r\n    this.keys.bind(this);\r\n  }\r\n\r\n  /**\r\n   * Recupera a instancia corrente do react pelo componente que o utilizará\r\n   * \r\n   * @param {object} react\r\n   * @return {object}\r\n   */\r\n  static getInstance(react) {\r\n    if (instance) {\r\n      return instance;\r\n    } else {\r\n      instance = new DeathStar(react);\r\n      return instance;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recria o componente informado com seu devido mapeamento para manipulação\r\n   * \r\n   * @param {string | object} type \r\n   * @param {object} props \r\n   * @param {object} children\r\n   * @return {object}\r\n   */\r\n  builder(type, props, children) {\r\n    if (children && children.length === 0) children = null;\r\n    props = props.children ? Object.assign({}, props, { children: null }) : props;\r\n    props = (Object.keys(props).indexOf('key') !== -1) ? Object.assign({}, props, { key: props.key }) : Object.assign({}, props, { key: this.getId() });\r\n    return this.createElement(type, props, children);\r\n  }\r\n\r\n  /**\r\n   * Limpa o repositório local de informações\r\n   */\r\n  clearBus() {\r\n    this.storage = {};\r\n  }\r\n\r\n  /**\r\n   * Persiste os dados informados no repositório local\r\n   * \r\n   * @param {string} key \r\n   * @param {object} value \r\n   * @param {object} context\r\n   * @return {object | undefined}\r\n   */\r\n  putStore(key, value, context) {\r\n    if (context) {\r\n      value['deathStartUpdater'] = () => { value.forceUpdate(); };\r\n      let temp = {};\r\n      Object.keys(value).map((current) => {\r\n        if (typeof (value[current]) === 'function') {\r\n          temp[current] = value[current];\r\n        }\r\n      });\r\n      temp['state'] = value.state;\r\n      this.storage[key] = temp;\r\n    } else {\r\n      this.storage[key] = value;\r\n      return value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recupera o dado do repositório por meio da 'Key' informada \r\n   * \r\n   * @param {string} key\r\n   * @return {object}\r\n   */\r\n  getStore(key) {\r\n    return this.storage[key];\r\n  }\r\n\r\n  /**\r\n   * Remove o objeto do repositório por meio da 'Key' informada\r\n   * \r\n   * @param {string} key \r\n   */\r\n  deleteStore(key) {\r\n    delete this.storage[key];\r\n  }\r\n\r\n  /**\r\n   * Recupera todas as chaves realcionadas aos objetos persistidos no repositório\r\n   * @return {array}\r\n   */\r\n  keys() {\r\n    return Object.keys(this.storage);\r\n  }\r\n\r\n  /**\r\n   * Destrói os elementos React do repositório por meio da lista de Arrays informados.\r\n   * \r\n   * @param {array | string} keys \r\n   */\r\n  destroy(keys) {\r\n    if (keys instanceof Array) {\r\n      let store = this.keys();\r\n      keys.map((currentItem) => {\r\n        store.map((currentStore) => {\r\n          if (currentStore.split('-')[0] === currentItem) {\r\n            this.deleteStore(currentItem);\r\n          }\r\n        }, this);\r\n      }, this);\r\n    } else {\r\n      let store = this.keys();\r\n      store.map((currentStore) => {\r\n        if (currentStore.split('-')[0] === keys) {\r\n          this.deleteStore(currentStore);\r\n        }\r\n      }, this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Realiza a minificação dos tipos de objetos React fazendo a compressão de nomes dos componentes.\r\n   * \r\n   * @param {string} key\r\n   * @return {string}\r\n   */\r\n  minf(key) {\r\n    if (this.minify) {\r\n      key.match(/(-\\w[a-zA-Z]+)/g) ? key.match(/(-\\w[a-zA-Z]+)/g).map((current) => {\r\n        if (this.htmlDict.indexOf(current.substring(1, key.length)) === -1) {\r\n          key = key.replace(current.substring(1, key.length), \"t\");\r\n        }\r\n      }) : \"\";\r\n    }\r\n    return key;\r\n  }\r\n\r\n  /**\r\n   * Prepara um container de informações para serem criadas e indexadas.\r\n   * \r\n   * @param {object} data \r\n   * @param {boolean} copy\r\n   * @return {object}\r\n   */\r\n  container(data, copy = false) {\r\n    let newProps = data.props;\r\n    if (Object.keys(data).indexOf('key') !== -1 && data['key'] && !copy) newProps = Object.assign({}, newProps, { key: data.key });\r\n    if (Object.keys(data).indexOf('ref') !== -1 && data['ref']) newProps = Object.assign({}, newProps, { ref: data.ref });\r\n    return this.builder(data.type, newProps ? newProps : null, Object.keys(data.props).indexOf('children') !== -1 ? this.processChildren(data.props.children, copy) : []);\r\n  }\r\n\r\n  /**\r\n   * Processa os filhos de um elemento React para que possam ser mapeados para manipulação.\r\n   * \r\n   * @param {object | array} children \r\n   * @param {boolean} copy\r\n   * @return {object}\r\n   */\r\n  processChildren(children, copy) {\r\n    return children ? children instanceof Array ? children.length > 0 ? children.map(function (arrChild) {\r\n      if (arrChild) return arrChild.type ? this.container(arrChild, copy) : arrChild;\r\n    }, this) : null : children.type ? this.container(children, copy) : children : null;\r\n  }\r\n\r\n  /**\r\n   * Processa um elemento React para que possam ser mapeado para manipulação.\r\n   * \r\n   * @param {object} data \r\n   * @param {string} key \r\n   * @param {boolean} copy\r\n   * @return {object}\r\n   */\r\n  processElement(data, key, copy = false) {\r\n    let obj = this.setStore(key, data, copy);\r\n    this.mapChildrens(obj.props.children, key);\r\n    return this.manipulate(key);\r\n  }\r\n\r\n  /**\r\n   * Mapeia os filhos processados de um elemento para indexação no repositório\r\n   * \r\n   * @param {object} data \r\n   * @param {string} key \r\n   */\r\n  mapChildrens(data, key) {\r\n    if (data) {\r\n      if (data instanceof Array) {\r\n        data.map(function (current, index) {\r\n          if (current) {\r\n            ++index;\r\n            if (current.props) this.mapChildrens(current.props.children, key + '-' + this.haveTypeName(current.type) + index);\r\n            if (current.props) this.putStore(key + '-' + this.haveTypeName(current.type) + index, current.key);\r\n          }\r\n        }, this);\r\n      } else {\r\n        if (data.props) this.mapChildrens(data.props.children, key + '-' + this.haveTypeName(data.type) + '1');\r\n        if (data.props) this.putStore(key + '-' + this.haveTypeName(data.type) + '1', data.key);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verifica se o tipo do componente já foi inserido no dicionário de tipos, caso não exista ele o insere\r\n   * \r\n   * @param {string} type\r\n   * @return {string}\r\n   */\r\n  haveTypeName(type) {\r\n    if (this.minify && typeof type === 'string') {\r\n      if (this.htmlDict.indexOf(type) === -1) this.htmlDict.push(type);\r\n    }\r\n    return type.displayName ? type.displayName : type.name ? type.name : type;\r\n  }\r\n\r\n  /**\r\n   * Recupera um ID único para uso no mapeamento de elementos.\r\n   * @return {string}\r\n   */\r\n  getId() {\r\n    function s4() {\r\n      return Math.floor((1 + Math.random()) * 0x10000)\r\n        .toString(16)\r\n        .substring(1);\r\n    }\r\n    return s4() + s4() + '_' + s4() + '_' + s4() + '_' +\r\n      s4() + '_' + s4() + s4() + s4();\r\n  }\r\n\r\n  /**\r\n   * Insere no repositório um elemento react novo\r\n   * \r\n   * @param {string} key \r\n   * @param {object} jsxData \r\n   * @param {boolean} copy\r\n   * @return {object}\r\n   */\r\n  setStore(key, jsxData, copy = false) {\r\n    return this.putStore(key, this.container(jsxData, copy));\r\n  }\r\n\r\n  /**\r\n   * Recupera um elemento React do repositório e o disponibiliza para manipulação.\r\n   * \r\n   * @param {string} key\r\n   * @return {object}\r\n   */\r\n  manipulate(key) {\r\n    key = this.minf(key);\r\n    return this.checkKey(key) ? new Bridge(key) : '';\r\n  }\r\n\r\n  /**\r\n   * Recupera um elemento React do repositório cria uma cópia com a nova chave e o disponibiliza para manipulação.\r\n   * \r\n   * @param {string} key \r\n   * @param {string} newKey\r\n   * @return {object}\r\n   */\r\n  manipulateCopy(key, newKey) {\r\n    key = this.minf(key);\r\n    return this.manipulate(key).copy(newKey);\r\n  }\r\n\r\n  /**\r\n   * Recupera um elemento do repositório para renderização\r\n   * \r\n   * @param {string} key\r\n   * @return {object}\r\n   */\r\n  getElement(key) {\r\n    key = this.minf(key);\r\n    if (this.checkKey(key)) {\r\n      let temp = this.getStore(key);\r\n      let keyMaster = temp.props ? temp.key : temp;\r\n      let keyArr = key.split('-');\r\n      if (this.checkKey(keyArr[0])) {\r\n        let obj = this.getStore(keyArr[0]);\r\n        return obj.key === keyMaster ? obj : this.walkChildren(obj.props.children, keyMaster);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recupera do repositório e insere um novo Props no elemento relacionado a key informada.\r\n   * \r\n   * @param {string} key \r\n   * @param {object} props \r\n   */\r\n  setProps(key, props) {\r\n\r\n    if (!key && !(props instanceof Object)) {\r\n      console.log('metodo: setProps - Você precisa especificar uma key em string e um props no formato objeto!');\r\n      return;\r\n    }\r\n    if (this.checkKey(key)) {\r\n      let tempJsx = this.getElement(key);\r\n      if (Object.keys(props).indexOf('ref') !== -1) {\r\n        tempJsx = Object.assign({}, tempJsx, { ref: props.ref });\r\n        delete props.ref;\r\n      }\r\n      tempJsx = this.swapPropsAttr(tempJsx, props);\r\n      this.updateAllReferences(tempJsx);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Realiza a descoberta de elementos filhos de um elemento e retorna os elementos encontrados.\r\n   * \r\n   * @param {object} data \r\n   * @param {string} key\r\n   * @return {array}\r\n   */\r\n  walkChildren(data, key) {\r\n    let walk = '';\r\n    if (data) {\r\n      if (data instanceof Array) {\r\n        for (let x = 0; x < data.length; x++) {\r\n          if (data[x]) {\r\n            if (data[x].key === key) return data[x];\r\n            else if (data[x].props) walk = this.walkChildren(data[x].props.children, key);\r\n            if (walk && walk.key === key) return walk;\r\n          }\r\n        }\r\n      } else {\r\n        if (data.key === key) return data;\r\n        else if (data.props) walk = this.walkChildren(data.props.children, key);\r\n        if (walk && walk.key === key) return walk;\r\n      }\r\n    } return;\r\n  }\r\n\r\n  /**\r\n   * Recupera o elemento por meio de sua chave e realiza a cópia do mesmo por meio da nova chave\r\n   * \r\n   * @param {string} key \r\n   * @param {string} keyNew\r\n   * @return {object | undefined} \r\n   */\r\n  copy(key, keyNew) {\r\n    return this.checkKey(key) ? this.processElement(this.getElement(key), keyNew, true) : '';\r\n  }\r\n\r\n  /**\r\n   * Insere um novo atributo no objeto relacionado a chave informada.\r\n   * \r\n   * @param {string} key \r\n   * @param {object} attributes \r\n   */\r\n  setAttribute(key, attributes) {\r\n    if (!key && !attributes || !(attributes instanceof Object)) {\r\n      console.log('metodo: setAttributes - Você precisa especificar uma key em string e um atributo no formato objeto!');\r\n      return;\r\n    }\r\n    if (this.checkKey(key)) {\r\n      if (attributes.ref) {\r\n        let tempJsx = this.getElement(key);\r\n        let updated = Object.assign({}, tempJsx, attributes);\r\n        this.updateAllReferences(updated);\r\n      } else {\r\n        if (this.checkProps(key)) {\r\n          let tempJsx = this.getElement(key);\r\n          let updated = this.swapPropsAttr(tempJsx, attributes);\r\n          this.updateAllReferences(updated);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reaplica um novo valor ao atributo passado ao objeto por meio da chave informada.\r\n   * \r\n   * @param {string} key \r\n   * @param {object} attValues \r\n   */\r\n  modifyAttribute(key, attValues) {\r\n    Object.keys(attValues).map((current) => {\r\n      this.processModify(key, current, attValues[current]);\r\n    }, this);\r\n  }\r\n\r\n  /**\r\n   * Aplica as mudanças nos atributos de acordo com os valores informados.\r\n   * \r\n   * @param {string} key \r\n   * @param {string} atrName \r\n   * @param {*} value \r\n   */\r\n  processModify(key, atrName, value) {\r\n    if (!key && !atrName && !value) {\r\n      console.log('metodo: modifyAttribute - Você precisa especificar a key, o nome do atributo e seu valor por parâmetro!');\r\n      return;\r\n    }\r\n    if (this.checkKey(key)) {\r\n      if (this.checkProps(key)) {\r\n        if (this.checkAttribute(key, atrName) || atrName === 'ref') {\r\n          let tempJsx = this.getElement(key);\r\n          if (atrName === 'ref') {\r\n            let updated = Object.assign({}, tempJsx, { ref: value });\r\n            this.updateAllReferences(updated);\r\n          } else {\r\n            let tempVar = {};\r\n            tempVar[atrName] = value;\r\n            let updated = this.swapPropsAttr(tempJsx, tempVar);\r\n            this.updateAllReferences(updated);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recupera o elemento do repositório e realiza a remoção dos atributos informados\r\n   * \r\n   * @param {string} key \r\n   * @param {array | string} attValues \r\n   */\r\n  removeAttribute(key, attValues) {\r\n    if (attValues instanceof Array) {\r\n      attValues.map((current) => {\r\n        this.processRemove(key, current);\r\n      }, this);\r\n    } else {\r\n      this.processRemove(key, attValues);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Aplica a remoção dos atributos de acordo com os valores informados.\r\n   * \r\n   * @param {string} key \r\n   * @param {string} atrName \r\n   */\r\n  processRemove(key, atrName) {\r\n    if (!key && !atrName) {\r\n      console.log('metodo: removeAttribute - Você precisa especificar uma key em string e o nome do atributo a ser removido!');\r\n      return;\r\n    }\r\n    if (this.checkKey(key)) {\r\n      if (this.checkProps(key)) {\r\n        let tempJsx = this.getElement(key);\r\n        if (atrName === 'ref') {\r\n          let updated = Object.assign({}, tempJsx, { ref: null });\r\n          this.updateAllReferences(updated);\r\n        }\r\n        if (this.checkAttribute(key, atrName)) {\r\n          let index = Object.keys(tempJsx.props);\r\n          index.splice(index.indexOf(atrName), 1);\r\n          let tempObj = {};\r\n          index.map((current) => {\r\n            tempObj[current] = tempJsx.props[current];\r\n          });\r\n          let result = Object.assign({}, tempJsx, { props: tempObj });\r\n          this.updateAllReferences(result);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Realiza a inserção de um elemento filho em um outro elemento especificado pela chave.\r\n   * \r\n   * @param {string} key \r\n   * @param {object} childrenVal \r\n   * @param {integer} index \r\n   * @param {boolean} mergeIndex \r\n   */\r\n  setChildren(key, childrenVal, index = '', mergeIndex = false) {\r\n    if (!key && !childrenVal) {\r\n      console.log('metodo: setChildren - Você precisa especificar a key e um elemento a ser inserido!');\r\n      return;\r\n    }\r\n    if (this.checkKey(key)) {\r\n      let tempJsx = this.getElement(key);\r\n      if (this.checkProps(key)) {\r\n        if (tempJsx.props.children) {\r\n          if (childrenVal instanceof Array) {\r\n            let arrChild = tempJsx.props.children;\r\n            if (!(arrChild instanceof Array)) arrChild = new Array(arrChild);\r\n            let updated = {};\r\n            if (index) {\r\n              index--;\r\n              if (mergeIndex) arrChild.splice(index, 0, ...childrenVal);\r\n              else arrChild.splice(index, 1, ...childrenVal);\r\n              updated = this.swapPropsAttr(tempJsx, { children: arrChild });\r\n            } else updated = this.swapPropsAttr(tempJsx, { children: arrChild.concat(childrenVal) });\r\n            this.updateAllReferences(updated);\r\n          } else {\r\n            let arrChild = tempJsx.props.children instanceof Array ? tempJsx.props.children : new Array(tempJsx.props.children);\r\n            if (index) {\r\n              index--;\r\n              if (mergeIndex) arrChild.splice(index, 0, childrenVal);\r\n              else arrChild[index] = childrenVal;\r\n            } else {\r\n              arrChild.push(childrenVal);\r\n            }\r\n            let updated = this.swapPropsAttr(tempJsx, { children: arrChild });\r\n            this.updateAllReferences(updated);\r\n          }\r\n        } else {\r\n          let updated = this.swapPropsAttr(tempJsx, { children: childrenVal });\r\n          this.updateAllReferences(updated);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recupera um elemento pela chave e realiza a remoção do filho especificado pela indice informado.\r\n   * o indice obedece a regra da ordem dos filhos do elemento pai.\r\n   * \r\n   * @param {string} key \r\n   * @param {intger} index \r\n   */\r\n  removeChildren(key, index) {\r\n    if (index instanceof Array && index !== -1) {\r\n      index.map((current) => {\r\n        this.processRemoveChildren(key, current);\r\n      }, this);\r\n    } else if (index === -1) {\r\n      this.processResetChildren(key);\r\n    } else this.processRemoveChildren(key, index);\r\n  }\r\n\r\n  /**\r\n   * Aplica a remoção do filho de acordo com os valores informados.\r\n   * \r\n   * @param {string} key \r\n   * @param {integer} index \r\n   */\r\n  processRemoveChildren(key, index) {\r\n    index--;\r\n    if (!key && index) {\r\n      console.log('metodo: removeChildren - Você precisa especificar a key onde será retirada a children e o índice que corresponde a children a ser removida!');\r\n      return;\r\n    }\r\n    if (this.checkKey(key)) {\r\n      let jsxMaster = this.getElement(key);\r\n      if (jsxMaster.props.children instanceof Array) {\r\n        let newArr = jsxMaster.props.children.filter((current, idx) => index !== idx);\r\n        let updated = this.swapPropsAttr(jsxMaster, { children: newArr });\r\n        this.updateAllReferences(updated);\r\n      } else {\r\n        let updated = this.swapPropsAttr(jsxMaster, { children: null });\r\n        this.updateAllReferences(updated);\r\n      }\r\n    } else console.log('Chave não encontrada!');\r\n  }\r\n\r\n  /**\r\n   * Remove todos os filhos de um elemento recuperado pela chave.\r\n   * \r\n   * @param {string} key \r\n   */\r\n  processResetChildren(key) {\r\n    if (!key) {\r\n      console.log('metodo: removeChildren - Você precisa especificar a key onde será retirada os childrens !');\r\n      return;\r\n    }\r\n    if (this.checkKey(key)) {\r\n      let jsxMaster = this.getElement(key);\r\n      let updated = this.swapPropsAttr(jsxMaster, { children: null });\r\n      this.updateAllReferences(updated);\r\n    } else console.log('Chave não encontrada!');\r\n  }\r\n\r\n  /**\r\n   * Realiza a atualização das mudanças em todo o repositório\r\n   * \r\n   * @param {object} obj \r\n   */\r\n  updateAllReferences(obj) {\r\n\r\n    let keys = this.keys();\r\n    keys.map(function (current) {\r\n      let tempElement = this.getStore(current);\r\n      if (tempElement.props) {\r\n        if (tempElement.key !== obj.key) {\r\n          let childrenUpdated = this.checkChildrensInArray(obj, tempElement);\r\n          this.putStore(current, this.processElement(this.swapPropsAttr(tempElement, { children: childrenUpdated }), current).getElement());\r\n        } else this.putStore(current, this.processElement(obj, current).getElement());\r\n      }\r\n    }, this);\r\n  }\r\n\r\n  /**\r\n   * Verifica e aplica as mudanças nos filhos de um elemento pai.\r\n   * \r\n   * @param {object} mainElement \r\n   * @param {object} currentElement\r\n   * @return {object} \r\n   */\r\n  checkChildrensInArray(mainElement, currentElement) {\r\n\r\n    if (currentElement && currentElement.props) {\r\n      let childrens = currentElement.props.children;\r\n      let childrenUpdated = [];\r\n      if (childrens && childrens instanceof Array) {\r\n        childrens.map(function (current) {\r\n          let nextChildrens = this.checkChildrensInArray(mainElement, current);\r\n          childrenUpdated = this.compareChildrens(mainElement, current, childrenUpdated, nextChildrens);\r\n        }, this);\r\n        return childrenUpdated;\r\n      } else if (childrens && childrens.props) {\r\n        let nextChildrens = this.checkChildrensInArray(mainElement, childrens);\r\n        childrenUpdated = this.compareChildrens(mainElement, childrens, childrenUpdated, nextChildrens);\r\n        return childrenUpdated;\r\n      } else return childrens;\r\n    } else return currentElement;\r\n  }\r\n\r\n  /**\r\n   * Verifica se houve alteração no filho encontrado e recupera o filho atualizado.\r\n   * \r\n   * @param {object} mainElement \r\n   * @param {object} current \r\n   * @param {object} childrenUpdated \r\n   * @param {object} nextChildrens\r\n   * @return {object}\r\n   */\r\n  compareChildrens(mainElement, current, childrenUpdated, nextChildrens) {\r\n    if (current && current.key && current.key === mainElement.key) {\r\n      childrenUpdated.push(mainElement);\r\n    } else {\r\n      if (current && current.props) childrenUpdated.push(this.swapPropsAttr(current, { children: nextChildrens }));\r\n      else childrenUpdated.push(current);\r\n    }\r\n    return childrenUpdated;\r\n  }\r\n\r\n  /**\r\n   * Realiza a inserção de novos atributos a um elemento informado.\r\n   * \r\n   * @param {object} obj \r\n   * @param {object} newAttr\r\n   * @return {object} \r\n   */\r\n  swapPropsAttr(obj, newAttr) {\r\n    let tempProps = Object.assign({}, obj.props, newAttr);\r\n    return Object.assign({}, obj, { props: tempProps });\r\n  }\r\n\r\n  /**\r\n   * Verifica se existe algum item no repositório relacionado a chave informada.\r\n   * \r\n   * @param {string} key\r\n   * @return {boolean} \r\n   */\r\n  checkKey(key) {\r\n    return this.keys().indexOf(key) === -1 ? false : true;\r\n  }\r\n\r\n  /**\r\n   * Verifica se o elemento relacionado a chave informada contém props.\r\n   * \r\n   * @param {string} key\r\n   * @return {boolean} \r\n   */\r\n  checkProps(key) {\r\n    return this.checkKey(key) ? Object.keys(this.getElement(key)).indexOf('props') === -1 ? false : true : false;\r\n  }\r\n\r\n  /**\r\n   * Verifica se o elemento relacionado a chave informada contém o atributo indicado.\r\n   * \r\n   * @param {string} key \r\n   * @param {string} atrName\r\n   * @return {boolean} \r\n   */\r\n  checkAttribute(key, atrName) {\r\n    return this.checkKey(key) ? this.checkProps(key) ? Object.keys(this.getElement(key).props).indexOf(atrName) === -1 ? false : true : false : false;\r\n  }\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DeathStar.js","import deathStar from './DeathStar';\r\nexport default class Bridge {\r\n  constructor(key) {\r\n    this.instance = deathStar.getInstance();\r\n    this.key = this.instance.minf(key);\r\n  }\r\n  /**\r\n   * Retorna a chave relacionada a manipulação corrente\r\n   * \r\n   * @return {string}\r\n   */\r\n  getMyKey() {\r\n    return this.key;\r\n  }\r\n\r\n  /**\r\n   * Recupera o elemento relacionado a chave deste manipulador para renderização\r\n   * \r\n   * @return {object}\r\n   */\r\n  getElement() {\r\n    return this.instance.getElement(this.key);\r\n  }\r\n\r\n  /**\r\n   * Recupera o elemento relacionado a chave deste manipulador e realiza a cópia do mesmo por meio da nova chave\r\n   * \r\n   * @param {string} newKey\r\n   * @return {object | undefined}\r\n   */\r\n  copy(newKey) {\r\n    return this.instance.copy(this.key, newKey);\r\n  }\r\n\r\n  /**\r\n   * Insere novos atributos no objeto relacionado a chave deste manipulador.\r\n   * Return manipulador\r\n   * \r\n   * @param {object} attributes\r\n   * @return {object}\r\n   */\r\n  setAttribute(attributes) {\r\n    this.instance.setAttribute(this.key, attributes);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Recupera do repositório e insere um novo Props no elemento relacionado a chave deste manipulador.\r\n   * Return manipulador\r\n   * \r\n   * @param {object} props\r\n   * @return {object}\r\n   */\r\n  setProps(props) {\r\n    this.instance.setProps(this.key, props);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Reaplica um novo valor ao atributo passado ao objeto relacionado a chave deste manipulador.\r\n   * Return manipulador\r\n   * \r\n   * @param {object} value\r\n   * @return {object}\r\n   */\r\n  modifyAttribute(value) {\r\n    this.instance.modifyAttribute(this.key, value);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Recupera o elemento do repositório relacionado a chave deste manipulador e realiza a remoção dos atributos informados\r\n   * Return manipulador\r\n   * \r\n   * @param {string} atrName\r\n   * @return {object}\r\n   */\r\n  removeAttribute(atrName) {\r\n    this.instance.removeAttribute(this.key, atrName);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Realiza a inserção de um elemento filho em um outro elemento especificado relacionado a chave deste manipulador.\r\n   * Return manipulador\r\n   * \r\n   * @param {object} children \r\n   * @param {integer} index \r\n   * @param {boolean} mergeIndex\r\n   * @return {object}\r\n   */\r\n  setChildren(children, index = '', mergeIndex = false) {\r\n    this.instance.setChildren(this.key, children, index, mergeIndex);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Recupera um elemento relacionado a chave deste manipulador e realiza a remoção do filho especificado pela índice informado.\r\n   * o índice obedece a regra da ordem dos filhos do elemento pai.\r\n   * Return manipulador\r\n   * \r\n   * @param {integer} index\r\n   * @return {object}\r\n   */\r\n  removeChildren(index) {\r\n    this.instance.removeChildren(this.key, index);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Verifica se o elemento relacionado a chave deste manipulador contém o atributo indicado.\r\n   * \r\n   * @param {string} atrName\r\n   * @return {boolean} \r\n   */\r\n  checkAttribute(atrName) {\r\n    return this.instance.checkAttribute(this.key, atrName);\r\n  }\r\n\r\n  /**\r\n   * Recupera o elemento React relacionado a chave deste manipulador, cria uma cópia com a nova chave e o disponibiliza para manipulação.\r\n   * \r\n   * @param {string} newKey\r\n   * @return {object}\r\n   */\r\n  manipulateCopy(newKey) {\r\n    return this.instance.manipulateCopy(this.key, newKey);\r\n  }\r\n\r\n  /**\r\n   * Carrega este manipulador de elemento com a nova chave informada\r\n   * Return manipulador\r\n   * \r\n   * @param {string} key \r\n   * @return {object}\r\n   */\r\n  manipulate(key) {\r\n    this.key = this.instance.minf(key);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Destrói os elementos React do repositório por meio da lista de Arrays informados.\r\n   * Return manipulador\r\n   * \r\n   * @param {array | string} keys\r\n   * @return {object}\r\n   */\r\n  destroy(keys) {\r\n    this.instance.destroy(keys);\r\n    return this;\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Bridge.js","var ninf = {\r\n  minify: true\r\n};\r\n\r\nmodule.exports = ninf;\r\n\n\n\n// WEBPACK FOOTER //\n// ./minify.conf.js"],"sourceRoot":""}